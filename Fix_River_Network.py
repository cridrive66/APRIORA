# -*- coding: utf-8 -*-

"""
/***************************************************************************
 APRIORA
                                 A QGIS plugin
 Collection of APRIORA Plugins
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-06-13
        copyright            : (C) 2024 by Universität Rostock
        email                : cristiano.guidi2@uni-rostock.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Cristiano Guidi'
__date__ = '2024-06-13'
__copyright__ = '(C) 2024 by Universität Rostock'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os
import processing
from collections import Counter
from PyQt5.QtCore import QVariant
from qgis.gui import QgsMapToolEmitPoint
from qgis.PyQt.QtCore import QCoreApplication, Qt, QDir, QVariant
from qgis.core import (QgsProcessingAlgorithm,
                       QgsProcessing,
                       QgsProcessingException,
                       QgsFeature,
                       QgsField,
                       QgsFields,
                       QgsFeature,
                       QgsFeatureSink,
                       QgsGeometry,
                       QgsMultiLineString,
                       QgsPointXY,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterPoint,
                       QgsProject,
                       QgsField,
                       QgsVectorLayer,
                       QgsSpatialIndex,
                       Qgis,
                       edit)


class FixRiverNetwork(QgsProcessingAlgorithm):

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    catchmentAreas = 'CatchmentAreas'
    riverNetwork = 'RiverNetwork'
    FLIP_OPTION = 'FLIP_OPTION'
    OUTLET_POINT = 'OUTLET_POINT'
    SEARCH_RADIUS = 'SEARCH_BUFFER'
    OUTPUT = 'OUTPUT'

    def shortHelpString(self):
        return self.tr(""" This tool aligns the river network with the subcatchments' borders and calculates the contributing relationship between the different river sections.
        Workflow:
        1. Choose the catchment file and the river network.
        2. Click on the map where the outlet point is.
        3. Click on "Run".

        Please note: be sure that the river network does not present gaps and all the river sections are connected to each others.
        """)
    
    class PointSelectionTool(QgsMapToolEmitPoint):
        def __init__(self, canvas, callback):
            super().__init__(canvas)
            self.canvas = canvas
            self.callback = callback

        def canvasReleaseEvent(self, event):
            point = self.toMapCoordinates(event.pos())
            self.callback(QgsPointXY(point))

    #Init tool
    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.catchmentAreas,
                self.tr('Catchment areas'),
                [QgsProcessing.TypeVectorPolygon]
            )
        )
        
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.riverNetwork,
                self.tr('River network'),
                [QgsProcessing.TypeVectorLine]
            )
        )

        self.addParameter(
            QgsProcessingParameterEnum(
                self.FLIP_OPTION,
                self.tr("Flip lines according to flow direction?"),
                ['yes (from source to mouth)','no', 'against (from mouth to source)'],
                defaultValue=[0]
            )
        )

        self.addParameter(
            QgsProcessingParameterPoint(
                self.OUTLET_POINT,
                self.tr("Click on the map to specify the outlet point."),
                defaultValue=None
            )
        )

        try:
            rad_type = Qgis.ProcessingNumberParameterType.Double
        except:
            # for qgis prior to version 3.36
            rad_type = QgsProcessingParameterNumber.Double
        param_Radius = QgsProcessingParameterNumber(
                self.SEARCH_RADIUS,
                self.tr("Search Radius for Connections"),
                type=rad_type,
                defaultValue=0,
                minValue=0,
                maxValue=10,
                optional=True
            )
        param_Radius.setFlags(param_Radius.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(param_Radius)

        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Fixed river network'),
                QgsProcessing.TypeVectorPolygon
            )
        )

    def executePointSelection(self): #should I add "parameters, context, feedback"?
        """
        This function allows the user to click on the map and select the outlet point.
        """
        canvas = iface.mapCanvas()
        
        def pointSelected(point):
            self.outlet_point = QgsPointXY(point)
            iface.messageBar().pushMessage(
                f"Point selected: {point.x()}, {point.y()}",
                level = Qgis.Info
            )
            canvas.unsetMapTool(self._map_tool)
        
        # activate the map tool to select a point
        self._map_tool = FixRiverNetwork.PointSelectionTool(canvas, pointSelected)
        canvas.setMapTool(self._map_tool)
    
    def find_closest_vertex(self, parameters, context, feedback, point, spatial_index, vertex_map, threshold):
        nearest_ids = spatial_index.nearestNeighbor(QgsGeometry.fromPointXY(point), 5) # get 5 nearest vertices
        closest_vertex = None
        min_distance = threshold

        for vertex_id in nearest_ids:
            vertex = vertex_map[vertex_id]
            distance = QgsGeometry.fromPointXY(QgsPointXY(point)).distance(QgsGeometry.fromPointXY(QgsPointXY(vertex)))
            
            if distance < min_distance:
                closest_vertex = vertex
                min_distance = distance

        return closest_vertex

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        # before starting, let's check if the outlet point is correctly selected
        outlet_point = self.parameterAsPoint(parameters, self.OUTLET_POINT, context)
        if outlet_point is None:
            raise QgsProcessingException("No outlet point specified.")

        # add a new column to the catchment layer in order to identify each subcatchment
        subcatchments_layer = self.parameterAsVectorLayer(parameters, self.catchmentAreas, context)
        river_layer = self.parameterAsVectorLayer(parameters, self.riverNetwork, context)
        search_radius = self.parameterAsDouble(parameters, self.SEARCH_RADIUS, context)

        with edit(subcatchments_layer):
            field_name = "id_catch"
            fields = subcatchments_layer.fields()

            # check if the field already exists
            if field_name not in [field.name() for field in fields]:
                subcatchments_layer.dataProvider().addAttributes([QgsField(field_name, QVariant.Int)])
                subcatchments_layer.updateFields()
            else:
                feedback.pushInfo(f"\nField '{field_name}' already exists. Skipping field creation.")   #maybe the cause of the crashing is here

            # populate the new column with unique IDs
            unique_id_start = 100 #or any starting value
            for idx, feature in enumerate(subcatchments_layer.getFeatures(), start = unique_id_start):
                feature[field_name] = idx
                subcatchments_layer.updateFeature(feature)

        feedback.setProgressText(f"Number of features in subcatchments_layer: {subcatchments_layer.featureCount()}")

        # extract start [0] and end [-1] vertices from the river network
        feedback.setProgressText("\nExtracting start and end vertices from river network...")
        vertices_river_result = processing.run("native:extractspecificvertices", {
            'INPUT': river_layer,
            'VERTICES':'0, -1',
            'OUTPUT':'TEMPORARY_OUTPUT'},
            context=context, feedback=feedback)
        vertices_river_layer = vertices_river_result["OUTPUT"]

        feedback.setProgressText(f"Number of features in vertices_river_layer: {vertices_river_layer.featureCount()}")

        # extract all the vertices from the subcatchments
        feedback.setProgressText("\nExtracting vertices from the subcatchments...")
        vertices_catch_result = processing.run("native:extractvertices", {
            'INPUT':parameters[self.catchmentAreas],
            'OUTPUT':'TEMPORARY_OUTPUT'},
            context=context, feedback=feedback)
        vertices_catch_layer = vertices_catch_result["OUTPUT"]

        feedback.setProgressText(f"Number of features in vertices_catch_layer: {vertices_catch_layer.featureCount()}")

        # split river network at each river vertex (SAGA required)
        # maybe add a trouble shooting line to check if SAGA is installed and raise a proper error
        feedback.setProgressText("\nSplitting river network at each river vertex...")
        split_result = processing.run("sagang:splitlinesatpoints", {
            'LINES': parameters[self.riverNetwork],
            'SPLIT': vertices_river_layer,
            'INTERSECT':'TEMPORARY_OUTPUT',
            'OUTPUT': 1, # not sure about which method use
            'EPSILON':0},
            context=context, feedback=feedback)
        split_river_layer = QgsVectorLayer(split_result["INTERSECT"], "split_river", "ogr")

        feedback.setProgressText(f"Number of features in split_river_layer: {split_river_layer.featureCount()}")

        # the file has geometries that need to be fixed
        feedback.setProgressText("\nFixing the geometries of the file...")
        fixed_result = processing.run("native:fixgeometries", {
            'INPUT':split_river_layer,
            'METHOD':1, # not sure about which method use
            'OUTPUT':'TEMPORARY_OUTPUT'},
            context=context, feedback=feedback)
        fixed_layer = fixed_result["OUTPUT"]
        del split_river_layer

        feedback.setProgressText(f"Number of features in fixed_layer: {fixed_layer.featureCount()}")

        # remove null geometries from the layer
        feedback.setProgressText("\nRemoving the null geometries...")
        non_null_geom_result = processing.run("native:removenullgeometries", {
            'INPUT':fixed_layer,
            'REMOVE_EMPTY':True,
            'OUTPUT':'TEMPORARY_OUTPUT'},
            context=context, feedback=feedback)
        non_null_geom_layer = non_null_geom_result["OUTPUT"]
        del fixed_layer
        #QgsProject.instance().addMapLayer(non_null_geom_layer)
        feedback.setProgressText(f"Number of features in non_null_geom_layer: {non_null_geom_layer.featureCount()}")

        # get all points from the subcatchment vertices layer
        vertices_catch_points = [QgsPointXY(feature.geometry().asPoint()) for feature in vertices_catch_layer.getFeatures()]

        # collect changes before applying them
        features_to_update = []

        feedback.setProgressText("\nAlligning river vertices...")
        
        # threshold distand (adjust as needed)
        threshold = 0.01 # 1cm
        
        # build a spatial index
        spatial_index = QgsSpatialIndex()
        vertex_map = {}

        for vertex in vertices_catch_points:
            point_id = len(vertex_map) # unique ID for the spatial index
            vertex_map[point_id] = vertex

            # create feature and set ID and geometry
            feature = QgsFeature()
            feature.setId(point_id)
            feature.setGeometry(QgsGeometry.fromPointXY(vertex))
            spatial_index.insertFeature(feature)
        
        # iterate over river network vertices with optimized search
        features_to_update = []
        for feature in non_null_geom_layer.getFeatures():
            if feedback.isCanceled():
                feedback.pushInfo("Process canceled by user")
                return {}

            geom = feature.geometry()
            feature_id = feature.id()

            if geom:
                points = [QgsPointXY(point) for point in geom.vertices()]
                modified = False

                # find closest start & end points using spatial index
                closest_start = self.find_closest_vertex(parameters, context, feedback, points[0], spatial_index, vertex_map, threshold)
                if closest_start:
                    points[0] = closest_start
                    modified = True

                closest_end = self.find_closest_vertex(parameters, context, feedback, points[-1], spatial_index, vertex_map, threshold)
                if closest_end:
                    points[-1] = closest_end
                    modified = True

                # if modified, store for batch update
                if modified:
                    new_geom = QgsGeometry.fromPolylineXY(points)
                    feature.setGeometry(new_geom)
                    features_to_update.append(feature)
            
        # apply updates in batch mode
        with edit(non_null_geom_layer):
            for feature in features_to_update:
                non_null_geom_layer.updateFeature(feature)

        feedback.setProgressText(f"\nNumber of features in non_null_geom_layer after editing: {non_null_geom_layer.featureCount()}")
        #QgsProject.instance().addMapLayer(non_null_geom_layer)

        # # align start points of river network vertices
        # for feature in non_null_geom_layer.getFeatures(): # this part of the code is computationally very intense, so try to change it (add bounding box instead of for loop?)
        #     geom = feature.geometry()
        #     feature_id = feature.id()
            
        #     if geom:
        #         # extract geometry points as QgsPointXY objects
        #         points = [QgsPointXY(point) for point in geom.vertices()]
        #         modified = False
                
        #         # check start vertex
        #         closest_start = self.find_closest_vertex(parameters, context, feedback, points[0], vertices_catch_points, threshold)
        #         if closest_start:
        #             points[0] = closest_start
        #             modified = True

        #         # check end vertex
        #         closest_end = self.find_closest_vertex(parameters, context, feedback, points[-1], vertices_catch_points, threshold)
        #         if closest_end:
        #             points[-1] = closest_end
        #             modified = True
                    
        #         # collect changes if modified:
        #         if modified:
        #             new_geom = QgsGeometry.fromPolylineXY(points)
        #             feature.setGeometry(new_geom)
        #             features_to_update.append(feature)

        # # apply updates in batch mode
        # with edit(non_null_geom_layer):
        #     for feature in features_to_update:
        #         non_null_geom_layer.updateFeature(feature)

        # feedback.setProgressText(f"\nNumber of features in non_null_geom_layer after editing: {non_null_geom_layer.featureCount()}")

        
        # identify invalid geometries before starting the intersection process
        feedback.setProgressText("\nChecking for invalid geometries...")
        invalid_features = []
        for feature in non_null_geom_layer.getFeatures():
            if not feature.isValid():
                invalid_features.append(feature)

        if invalid_features:
            feedback.reportError(f"Found {len(invalid_features)} invalid geometries!", fatalError = False)

            # create a new memory layer for invalid features
            invalid_layer = QgsVectorLayer("LineString?crs=" + non_null_geom_layer.crs().authid(), "Invalid Geometries", "memory")
            provider = invalid_layer.dataProvider()

            # copy fields and add invalid features
            provider.addAttributes(non_null_geom_layer.fields())
            invalid_layer.updateFields()

            for feature in invalid_features:
                provider.addFeature(feature)

            # add the layer to the QGIS map
            QgsProject.instance().addMapLayer(invalid_layer)

            feedback.reportError("Invalid geometries have been added to the map. Please fix them and rerun the process.", fatalError = True)
            raise QgsProcessingException("Invalid geometries detected. Check the 'Invalid Geometries' layer.")
        
        # in "non null geom" there are several features with length of 0 or very close to 0. Let's remove them before the intersection
        min_length_threshold = 0.01

        # filter out short geometries
        with edit(non_null_geom_layer):
            features_to_delete = []
            for feature in non_null_geom_layer.getFeatures():
                geom = feature.geometry()
                if geom and geom.isGeosValid():
                    length = geom.length()

                    if length < min_length_threshold:
                        features_to_delete.append(feature.id())

            # delete all short features
            if features_to_delete:
                non_null_geom_layer.dataProvider().deleteFeatures(features_to_delete)
                feedback.reportError(f"\nDeleted {len(features_to_delete)} short features below {min_length_threshold}.")

        
        # fix geometries from the layer
        feedback.setProgressText("\nFixing geometries...")
        again_fixed_layer = processing.run("native:fixgeometries", {
            'INPUT':non_null_geom_layer,
            'METHOD':1,
            'OUTPUT':'TEMPORARY_OUTPUT'},
            context=context, feedback=feedback)["OUTPUT"]
        

        # intersection with subcatchments
        feedback.setProgressText("\nCalculating intersection with the subcatchments...")
        intersection_layer = processing.run("native:intersection", {
            'INPUT': again_fixed_layer,
            'OVERLAY': parameters[self.catchmentAreas],
            'INPUT_FIELDS':[],
            'OVERLAY_FIELDS':[],
            'OVERLAY_FIELDS_PREFIX':'',
            'OUTPUT':'TEMPORARY_OUTPUT',
            'GRID_SIZE':None},
            context=context, feedback=feedback)["OUTPUT"]
        #QgsProject.instance().addMapLayer(intersection_layer)

        # delete mistakes of river sections that are wrongly crossing the subcatchment
        # define the threshold length
        threshold_length = 0.0 

        # prepare to edit the layer
        with edit(intersection_layer):
            features_to_delete = []
            for feature in intersection_layer.getFeatures():
                geom = feature.geometry()
                if geom and geom.isGeosValid():
                    length = geom.length()

                    if length < threshold_length:
                        features_to_delete.append(feature.id())

            # delete all short features
            if features_to_delete:
                intersection_layer.dataProvider().deleteFeatures(features_to_delete)
                feedback.reportError(f"\nDeleted {len(features_to_delete)} short features below {threshold_length}.")
        

        # dissolve line within the subcatchment
        # feedback.setProgressText("\nDissolving river lines within the subcatchment...")
        # dissolve_layer = processing.run("native:dissolve", {
        #     'INPUT': intersection_layer,
        #     'FIELD':['id_apr'],
        #     'SEPARATE_DISJOINT':False,
        #     'OUTPUT':'TEMPORARY_OUTPUT'},
        #     context=context, feedback=feedback)["OUTPUT"]
        
        dissolve_layer = intersection_layer
        #QgsProject.instance().addMapLayer(dissolve_layer)
        
        with edit(dissolve_layer):
            field_name = "id_riv"
            fields = dissolve_layer.fields()

            # check if the field already exists
            if field_name not in [field.name() for field in fields]:
                dissolve_layer.dataProvider().addAttributes([QgsField(field_name, QVariant.Int)])
                dissolve_layer.updateFields()
            else:
                feedback.pushInfo(f"\nField '{field_name}' already exists. Skipping field creation.")   #maybe the cause of the crashing is here

            # populate the new column with unique IDs
            unique_id_start = 1000 #or any starting value
            for idx, feature in enumerate(dissolve_layer.getFeatures(), start = unique_id_start):
                feature[field_name] = idx
                dissolve_layer.updateFeature(feature)

        

        '''start of the plugin "WaterNetwConstructor" from Jannik Schilling'''
        flip_opt = self.parameterAsInt(parameters, self.FLIP_OPTION, context)

        sp_index = QgsSpatialIndex(dissolve_layer.getFeatures())
        dissolve_fields = dissolve_layer.fields()

        # retrieving the ID column
        idxid = dissolve_layer.fields().indexFromName("id_riv")  

        feedback.pushInfo(f"\nUsing outlet point: {outlet_point.x()}, {outlet_point.y()}")

        def find_closest_river_section(outlet_point, river_network): # change this one and add a spatial index as well
            """
            Function to define the closest river section to the outlet_point
            """
            closest_section = None
            min_distance = float('inf')

            # convert the outlet_point to QgsGeometry
            outlet_geometry = QgsGeometry.fromPointXY(outlet_point)

            # iterate through river network sections and find the closest
            for feature in river_network.getFeatures():
                section_geom = feature.geometry()
                distance = section_geom.distance(outlet_geometry)
                #feedback.pushInfo(f"\nAnalising section [id_riv]: {feature['id_riv']} \nDistance to the outlet point: {distance}")

                if distance < min_distance:
                    min_distance = distance
                    closest_section = feature

            return closest_section

        closest_section = find_closest_river_section(outlet_point, dissolve_layer)
        if closest_section is None:
            raise QgsProcessingException("No closest river section identified")
        feedback.pushInfo(f"\nClosest section [id_riv]: {closest_section['id_riv']}")

        # define new fields for the output
        out_fields = QgsFields()
        # append fields
        for field in dissolve_fields:
            out_fields.append(QgsField(field.name(), field.type()))
        out_fields.append(QgsField('NET_ID', QVariant.String, "String", 255))
        out_fields.append(QgsField('NET_TO', QVariant.String, "String", 255))
        out_fields.append(QgsField('NET_FROM', QVariant.String, "String", 255))
        # lists for results
        finished_segm = {}  # {qgis id: [net_id, net_to, net_from]}
        netw_dict = {}  # a dict for individual network numbers
        circ_list = []  # list for found circles
        flip_list = []  # list to flip geometries according or against flow direction

        def get_features_data(ft):
            '''
            Extracts the required data from a line feature
            :param QgsFeature ft
            :return: list with first_vertex, last_vertex, feature_id, (feature_name)
            '''
            ge = ft.geometry()
            vertex_list = [v for v in ge.vertices()]
            vert1 = QgsGeometry().fromPoint(vertex_list[0])
            vert2 = QgsGeometry().fromPoint(vertex_list[-1])
            column_id = str(ft.attribute(idxid))
            return [vert1, vert2, ft.id(), column_id]

        def get_id_and_vertice_if_connected(
            cd_id,
            search_geom,
            finished_segm,
            current_id,
            flip_list,
            finished_ids
        ):
            """
            :param int cd_id 
            :param QgsGeometry (polygon or point) search_geom
            :param dict finished_segm
            :param int current_id
            :param list flip_list
            :param list finished_ids
            :return: tuple (cd_id, connecting_point)
            """
            ft = dissolve_layer.getFeature(cd_id)
            ft_data = get_features_data(ft)
            # first vertex connecting
            if search_geom.intersects(ft_data[0]):
                if search_geom.intersects(ft_data[1]):
                    raise QgsProcessingException(
                        'Feature '+str(ft_data[-1])+' is a circle itself'
                    )
                else:
                    flip_list.append(cd_id)
                    # return the other vertex (connecting to the next feature)
                    result_tuple = (cd_id, ft_data[1])
            # last vertex connecting
            elif search_geom.intersects(ft_data[1]):
                # return the other vertex (connecting to the next feature)
                result_tuple = (cd_id, ft_data[0])
            else:
                result_tuple = None
            # check for circles
            if result_tuple:
                if cd_id in finished_ids:  # already visited -> cirlce
                    circ_list.append([current_id, cd_id])
                    # delete from connected_list if part of a circle
                    result_tuple = None
                else:
                    finished_segm[cd_id] = [
                        str(ft_data[-1]),
                        str(finished_segm[current_id][0]),
                        str(ft_data[-1])
                    ]
                    finished_ids.append(cd_id)
            return result_tuple

        def get_connected_list(
            connecting_point,
            current_id,
            search_radius,
            finished_segm,
            flip_list,
            finished_ids
        ):
            '''
            Searches for connected features at the connecting point, except for the current feature; also returns the search area
            :param QgsGeometry (Point) connecting_point
            :param int current_id
            :param float search_radius
            :param dict finished_segm
            :param list flip_list
            :param list finished_ids
            :return: list
            '''
            if search_radius != 0:
                search_geom = connecting_point.buffer(search_radius, 10)
                search_area = search_geom.boundingBox()
            else:
                search_geom = connecting_point
                search_area = connecting_point.boundingBox()
            candidates_list = sp_index.intersects(search_area)
            if current_id in candidates_list:  # remove self
                candidates_list.remove(current_id)
            connected_list = [
                get_id_and_vertice_if_connected(
                    cd_id,
                    search_geom,
                    finished_segm,
                    current_id,
                    flip_list,
                    finished_ids
                ) for cd_id in candidates_list
            ]
            return connected_list

        '''data of first segment'''
        finished_ids = []  # list to recognise already visited features
        to_do_list = []  # empty list for tributaries to visit later
        first_ft_data = get_features_data(closest_section)  # first_vertex, last_vertex, feature_id, (feature_name)
        out_marker = "Out"  # mark segment as outlet
        start_f_id = first_ft_data[2]
        finished_segm[first_ft_data[2]] = [
            str(first_ft_data[-1]),
            out_marker,
            str(first_ft_data[-1])
        ]
        finished_ids.append(first_ft_data[2])
        
        '''find connecting vertex of (first) first_ft_data, add to flip_list if conn_vert is not vert1'''
        connected_list_0 = get_connected_list(
            first_ft_data[0],  # vertex0
            first_ft_data[2],  # current_id
            search_radius,
            finished_segm,
            flip_list,
            finished_ids
        )
        connected_list_1 = get_connected_list(
            first_ft_data[1],
            first_ft_data[2],
            search_radius,
            finished_segm,
            flip_list,
            finished_ids
        )
        # remove none
        connected_list_0 = [f for f in connected_list_0 if f]
        connected_list_1 = [f for f in connected_list_1 if f]
        
        if len(connected_list_1) > 0:  # last vertex connecting
            if len(connected_list_0) > 0:  # both vertices connecting
                feedback.reportError(
                    self.tr(
                        'The selected segment with id == {0} is connecting two segments.'
                        +' Please chose another segment in layer "{1}" or add a segment as a single outlet'
                    ).format(first_ft_data[2], parameters[self.INPUT_LAYER]))
                raise QgsProcessingException()
            else:
                connected_list = connected_list_1

        else:  # first vertex connecting
            connected_list = connected_list_0  
        current_id = start_f_id
        
        '''loop: while still connected features, add to finished_segm'''
        while True:
            if feedback.isCanceled():
                print('finished so far: '+ str(finished_ids))
                print('current id'+ str(current_id))
                break

            if len(connected_list) == 0:
                if len(to_do_list)==0:
                    netw_dict["network"] = finished_ids
                    break
                else:
                    current_id, connecting_point = to_do_list[0]
                    to_do_list = to_do_list[1:]
            if len(connected_list) == 1:
                current_id, connecting_point = connected_list[0]
            if len(connected_list) > 1:
                current_id, connecting_point = connected_list[0]
                to_do_list = to_do_list + connected_list[1:]

           
            # get list of next connected features
            connected_list = get_connected_list(
                connecting_point,
                current_id,
                search_radius,
                finished_segm,
                flip_list,
                finished_ids
            )
            # remove none
            connected_list = [f for f in connected_list if f]

        
        '''feedback for circles'''
        if len(circ_list)>0:
            circ_dict = Counter(tuple(sorted(lst)) for lst in circ_list)
            circ_list_out = [f_ids for f_ids, counted in circ_dict.items() if counted > 1]
            if len(circ_list_out)>0:
                feedback.pushWarning("Warning: Circle closed at NET_ID = ")
                for f_ids in circ_list_out:
                    feedback.pushWarning(self.tr('{0}, ').format(str(f_ids)))


        '''sink definition'''
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            out_fields,
            dissolve_layer.wkbType(),
            dissolve_layer.sourceCrs())

        '''adjust_flip_list, if option is 2 (against)'''
        if flip_opt == 2:
            all_visited_ids = [f_id for id_list in netw_dict.values() for f_id in id_list]
            flip_list = [f_id for f_id in all_visited_ids if f_id not in flip_list]


        # # identify the index of "id_apr", I dont want it in the final output
        # id_apr_index = dissolve_fields.indexOf("id_apr")
        # if id_apr_index != -1:
        #     with edit(dissolve_layer):
        #         dissolve_layer.dataProvider().deleteAttributes([id_apr_index])
        #         dissolve_layer.updateFields()
        # else:
        #     feedback.pushInfo("'id_apr' field not found in dissolve layer.")
            
        '''add features to sink'''
        features = dissolve_layer.getFeatures()
        for i, feature in enumerate(features):
            if feedback.isCanceled():
                break # Stop the algorithm if cancel button has been clicked
            old_f_id = feature.id()
            outFt = QgsFeature() # Add a feature
            if flip_opt == 0 or flip_opt == 2:
                if old_f_id in flip_list:
                    flip_geom = feature.geometry()
                    if flip_geom.isMultipart():
                        multi_geom = QgsMultiLineString()
                        for line in flip_geom.asGeometryCollection():
                            multi_geom.addGeometry(line.constGet().reversed())
                        rev_geom = QgsGeometry(multi_geom)
                    else:
                        rev_geom = QgsGeometry(flip_geom.constGet().reversed())
                    outFt.setGeometry(rev_geom)
                else:
                    outFt.setGeometry(feature.geometry())  # not in flip list
            else:
                outFt.setGeometry(feature.geometry())  # no flip option
            if old_f_id in finished_segm.keys():
                outFt.setAttributes(feature.attributes()+finished_segm[old_f_id])
            else:
                ft_data = get_features_data(feature)
                outFt.setAttributes(feature.attributes()+[str(ft_data[-1]), 'unconnected', 'unconnected'])
            sink.addFeature(outFt, QgsFeatureSink.FastInsert)


        return {self.OUTPUT: dest_id}

        # # save the output layer
        # (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context,
        # dissolve_layer.fields(), dissolve_layer.wkbType(), dissolve_layer.sourceCrs())

        # if dissolve_layer is None:
        #     raise QgsProcessingException(self.tr("Failed to create river layer"))

        # # write features from dissolve_layer to the sink
        # for feature in dissolve_layer.getFeatures():  # name to change
        #     success = sink.addFeature(feature)
        #     if not success:
        #         feedback.pushInfo(f"Failed to add feature: {feature.id()}")

        # return {self.OUTPUT: dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '1 - Fix river network'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return FixRiverNetwork()