# -*- coding: utf-8 -*-

"""
/***************************************************************************
 APRIORA
                                 A QGIS plugin
 Collection of APRIORA Plugins
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-06-13
        copyright            : (C) 2024 by Universität Rostock
        email                : cristiano.guidi2@uni-rostock.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Universität Rostock'
__date__ = '2024-06-13'
__copyright__ = '(C) 2024 by Universität Rostock'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os
import processing
from collections import Counter
from PyQt5.QtCore import QVariant
from qgis.gui import QgsMapToolEmitPoint
from qgis.PyQt.QtCore import QCoreApplication, Qt, QDir, QVariant
from qgis.core import (QgsProcessingAlgorithm,
                       QgsProcessing,
                       QgsProcessingException,
                       QgsFeature,
                       QgsField,
                       QgsFields,
                       QgsFeatureSink,
                       QgsGeometry,
                       QgsMultiLineString,
                       QgsPointXY,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterPoint,
                       QgsField,
                       QgsVectorLayer,
                       QgsSpatialIndex,
                       Qgis,
                       edit)


class FixRiverNetwork(QgsProcessingAlgorithm):

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    catchmentAreas = 'CatchmentAreas'
    riverNetwork = 'RiverNetwork'
    FLIP_OPTION = 'FLIP_OPTION'
    OUTLET_POINT = 'OUTLET_POINT'
    SEARCH_RADIUS = 'SEARCH_BUFFER'
    OUTPUT = 'OUTPUT'
    
    class PointSelectionTool(QgsMapToolEmitPoint):
        def __init__(self, canvas, callback):
            super().__init__(canvas)
            self.canvas = canvas
            self.callback = callback

        def canvasReleaseEvent(self, event):
            point = self.toMapCoordinates(event.pos())
            self.callback(QgsPointXY(point))

    #Init tool
    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.catchmentAreas,
                self.tr('Catchment areas'),
                [QgsProcessing.TypeVectorPolygon]
            )
        )
        
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.riverNetwork,
                self.tr('River network'),
                [QgsProcessing.TypeVectorLine]
            )
        )

        self.addParameter(
            QgsProcessingParameterEnum(
                self.FLIP_OPTION,
                self.tr("Flip lines according to flow direction?"),
                ['yes (from source to mouth)','no', 'against (from mouth to source)'],
                defaultValue=[0]
            )
        )

        self.addParameter(
            QgsProcessingParameterPoint(
                self.OUTLET_POINT,
                self.tr("Click on the map to specify the outlet point."),
                defaultValue=None
            )
        )

        try:
            rad_type = Qgis.ProcessingNumberParameterType.Double
        except:
            # for qgis prior to version 3.36
            rad_type = QgsProcessingParameterNumber.Double
            param_Radius = QgsProcessingParameterNumber(
                self.SEARCH_RADIUS,
                self.tr("Search Radius for Connections"),
                type=rad_type,
                defaultValue=0,
                minValue=0,
                maxValue=10,
                optional=True
            )
        param_Radius.setFlags(param_Radius.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(param_Radius)

        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output layer'),
                QgsProcessing.TypeVectorPolygon
            )
        )

    def executePointSelection(self): #should I add "parameters, context, feedback"?
        """
        This function allows the user to click on the map and select the outlet point.
        """
        canvas = iface.mapCanvas()
        
        def pointSelected(point):
            self.outlet_point = QgsPointXY(point)
            iface.messageBar().pushMessage(
                f"Point selected: {point.x()}, {point.y()}",
                level = Qgis.Info
            )
            canvas.unsetMapTool(self._map_tool)
        
        # activate the map tool to select a point
        self._map_tool = FixRiverNetwork.PointSelectionTool(canvas, pointSelected)
        canvas.setMapTool(self._map_tool)
    
    def find_closest_vertex(self, parameters, context, feedback, point, vertices, threshold):
        closest_vertex = None
        min_distance = threshold
        for vertex in vertices:
            distance = QgsGeometry.fromPointXY(QgsPointXY(point)).distance(QgsGeometry.fromPointXY(QgsPointXY(vertex)))
            if distance < min_distance:
                closest_vertex = vertex
                min_distance = distance 
        return closest_vertex

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        # before starting, let's check if the outlet point is correctly selected
        outlet_point = self.parameterAsPoint(parameters, self.OUTLET_POINT, context)
        if outlet_point is None:
            raise QgsProcessingException("No outlet point specified.")

        # add a new column to the catchment layer in order to identify each subcatchment
        subcatchments_layer = self.parameterAsVectorLayer(parameters, self.catchmentAreas, context)
        river_layer = self.parameterAsVectorLayer(parameters, self.riverNetwork, context)
        search_radius = self.parameterAsDouble(parameters, self.SEARCH_RADIUS, context)

        with edit(subcatchments_layer):
            field_name = "id_apr"
            subcatchments_layer.dataProvider().addAttributes([QgsField(field_name, QVariant.Int)])
            subcatchments_layer.updateFields()

            # populate the new column with unique IDs
            unique_id_start = 100 #or any starting value
            for idx, feature in enumerate(subcatchments_layer.getFeatures(), start = unique_id_start):
                feature[field_name] = idx
                subcatchments_layer.updateFeature(feature)

        feedback.setProgressText(f"Number of features in subcatchments_layer: {subcatchments_layer.featureCount()}")

        # extract start [0] and end [-1] vertices from the river network
        feedback.setProgressText("\nExtracting start and end vertices from river network...")
        vertices_river_result = processing.run("native:extractspecificvertices", {
            'INPUT': parameters[self.riverNetwork],
            'VERTICES':'0, -1',
            'OUTPUT':'TEMPORARY_OUTPUT'},
            context=context, feedback=feedback)
        vertices_river_layer = vertices_river_result["OUTPUT"]

        feedback.setProgressText(f"Number of features in vertices_river_layer: {vertices_river_layer.featureCount()}")

        # extract all the vertices from the subcatchments
        feedback.setProgressText("\nExtracting vertices from the subcatchments...")
        vertices_catch_result = processing.run("native:extractvertices", {
            'INPUT':parameters[self.catchmentAreas],
            'OUTPUT':'TEMPORARY_OUTPUT'},
            context=context, feedback=feedback)
        vertices_catch_layer = vertices_catch_result["OUTPUT"]

        feedback.setProgressText(f"Number of features in vertices_catch_layer: {vertices_catch_layer.featureCount()}")

        # split river network at each river vertex (SAGA required)
        # maybe add a trouble shooting line to check if SAGA is installed and raise a proper error
        feedback.setProgressText("\nSplitting river network at each river vertex...")
        split_result = processing.run("sagang:splitlinesatpoints", {
            'LINES': parameters[self.riverNetwork],
            'SPLIT': vertices_river_layer,
            'INTERSECT':'TEMPORARY_OUTPUT',
            'OUTPUT': 1, # not sure about which method use
            'EPSILON':0},
            context=context, feedback=feedback)
        split_river_layer = QgsVectorLayer(split_result["INTERSECT"], "split_river", "ogr")

        feedback.setProgressText(f"Number of features in split_river_layer: {split_river_layer.featureCount()}")

        # the file has geometries that need to be fixed
        feedback.setProgressText("\nFixing the geometries of the file...")
        fixed_result = processing.run("native:fixgeometries", {
            'INPUT':split_river_layer,
            'METHOD':1, # not sure about which method use
            'OUTPUT':'TEMPORARY_OUTPUT'},
            context=context, feedback=feedback)
        fixed_layer = fixed_result["OUTPUT"]
        del split_river_layer

        feedback.setProgressText(f"Number of features in fixed_layer: {fixed_layer.featureCount()}")

        # remove null geometries from the layer
        feedback.setProgressText("\nRemoving the null geometries...")
        non_null_geom_result = processing.run("native:removenullgeometries", {
            'INPUT':fixed_layer,
            'REMOVE_EMPTY':True,
            'OUTPUT':'TEMPORARY_OUTPUT'},
            context=context, feedback=feedback)
        non_null_geom_layer = non_null_geom_result["OUTPUT"]
        del fixed_layer

        feedback.setProgressText(f"Number of features in non_null_geom_layer: {non_null_geom_layer.featureCount()}")

        # get all points from the subcatchment vertices layer
        vertices_catch_points = [QgsPointXY(feature.geometry().asPoint()) for feature in vertices_catch_layer.getFeatures()]

        # collect changes before applying them
        features_to_update = []

        feedback.setProgressText("\nAlligning river vertices...")

        # threshold distand (adjust as needed)
        threshold = 0.01 # 1cm

        # align start points of river network vertices
        for feature in non_null_geom_layer.getFeatures():
            geom = feature.geometry()
            feature_id = feature.id()
            
            if geom:
                # extract geometry points as QgsPointXY objects
                points = [QgsPointXY(point) for point in geom.vertices()]
                modified = False
                
                # check start vertex
                closest_start = self.find_closest_vertex(parameters, context, feedback, points[0], vertices_catch_points, threshold)
                if closest_start:
                    points[0] = closest_start
                    modified = True

                # check end vertex
                closest_end = self.find_closest_vertex(parameters, context, feedback, points[-1], vertices_catch_points, threshold)
                if closest_end:
                    points[-1] = closest_end
                    modified = True
                    
                # collect changes if modified:
                if modified:
                    new_geom = QgsGeometry.fromPolylineXY(points)
                    feature.setGeometry(new_geom)
                    features_to_update.append(feature)

        # apply updates in batch mode
        with edit(non_null_geom_layer):
            for feature in features_to_update:
                non_null_geom_layer.updateFeature(feature)

        feedback.setProgressText(f"\nNumber of features in non_null_geom_layer after editing: {non_null_geom_layer.featureCount()}")

        # intersection with subcatchments
        feedback.setProgressText("\nCalculating intersection with the subcatchments...")
        intersection_layer = processing.run("native:intersection", {
            'INPUT': non_null_geom_layer,
            'OVERLAY': parameters[self.catchmentAreas],
            'INPUT_FIELDS':[],
            'OVERLAY_FIELDS':['id_apr'],
            'OVERLAY_FIELDS_PREFIX':'',
            'OUTPUT':'TEMPORARY_OUTPUT',
            'GRID_SIZE':None},
            context=context, feedback=feedback)["OUTPUT"]

        # delete mistakes of river sections that are wrongly crossing the subcatchment
        # define the threshold lenght
        threshold_length = 0.01 # 1 cm

        # prepare to edit the layer
        with edit(intersection_layer):
            # add a new field for length
            field_names = [field.name() for field in intersection_layer.fields()]
            if "Length" not in field_names:
                length_field = QgsField("Length", QVariant.Double)
                intersection_layer.dataProvider().addAttributes([length_field])
                intersection_layer.updateFields()

            # iterate over feature
            features_to_delete = []
            for feature in intersection_layer.getFeatures():
                geom = feature.geometry()
                if geom:
                    # calculate the length of the feature
                    length = geom.length()

                    # update the "Length" field
                    feature["Length"] = length
                    intersection_layer.updateFeature(feature)

                    # check if the length is below the threshold
                    if length < threshold_length:
                        features_to_delete.append(feature.id())

                # delete features below the threshold length
                if features_to_delete:
                    intersection_layer.dataProvider().deleteFeatures(features_to_delete)
            
            # delete the "Length" field        
            field_index = intersection_layer.fields().indexOf("Length")
            intersection_layer.dataProvider().deleteAttributes([field_index])
            intersection_layer.updateFields()
        
        feedback.setProgressText(f"\nRemoved {len(features_to_delete)} features shorter than {threshold_length}")

        # dissolve line within the subcatchment
        feedback.setProgressText("\nDissolving river lines within the subcatchment...")
        dissolve_layer = processing.run("native:dissolve", {
            'INPUT': intersection_layer,
            'FIELD':['id_apr'],
            'SEPARATE_DISJOINT':False,
            'OUTPUT':'TEMPORARY_OUTPUT'},
            context=context, feedback=feedback)["OUTPUT"]
        
        # consider here removing the "id_apr" field
        # still not clear if it can be useful or not

        # create as a second output also the catchment with the new id_apr? Might be useful to have it for the next parts of the plugin

        '''start of the plugin "WaterNetwConstructor" from Jannik Schilling'''
        flip_opt = self.parameterAsInt(parameters, self.FLIP_OPTION, context)

        sp_index = QgsSpatialIndex(dissolve_layer.getFeatures())
        dissolve_fields = dissolve_layer.fields()

        # retrieving the ID column
        idxid = dissolve_layer.fields().indexFromName("id_apr")  

        feedback.pushInfo(f"\nUsing outlet point: {outlet_point.x()}, {outlet_point.y()}")

        def find_closest_river_section(outlet_point, river_network):
            """
            Function to define the closest river section to the outlet_point
            """
            closest_section = None
            min_distance = float('inf')

            # convert the outlet_point to QgsGeometry
            outlet_geometry = QgsGeometry.fromPointXY(outlet_point)

            # iterate through river network sections and find the closest
            for feature in river_network.getFeatures():
                section_geom = feature.geometry()
                distance = section_geom.distance(outlet_geometry)
                feedback.pushInfo(f"\nAnalising section [id_apr]: {feature['id_apr']} \nDistance to the outlet point: {distance}")

                if distance < min_distance:
                    min_distance = distance
                    closest_section = feature

            return closest_section

        closest_section = find_closest_river_section(outlet_point, dissolve_layer)
        if closest_section is None:
            raise QgsProcessingException("No closest river section identified")
        feedback.pushInfo(f"\nClosest section [id_apr]: {closest_section['id_apr']}")

        # define new fields for the output
        out_fields = QgsFields()
        # append fields
        for field in dissolve_fields:
            out_fields.append(QgsField(field.name(), field.type()))
        out_fields.append(QgsField('NET_ID', QVariant.String))
        out_fields.append(QgsField('NET_TO', QVariant.String))
        out_fields.append(QgsField('NET_FROM', QVariant.String))
        # lists for results
        finished_segm = {}  # {qgis id: [net_id, net_to, net_from]}
        netw_dict = {}  # a dict for individual network numbers
        circ_list = []  # list for found circles

        def get_features_data(ft):
            '''
            Extracts the required data from a line feature
            :param QgsFeature ft
            :return: list with first_vertex, last_vertex, feature_id, (feature_name)
            '''
            ge = ft.geometry()
            vertex_list = [v for v in ge.vertices()]
            vert1 = QgsGeometry().fromPoint(vertex_list[0])
            vert2 = QgsGeometry().fromPoint(vertex_list[-1])
            column_id = str(ft.attribute(idxid))
            return [vert1, vert2, ft.id(), column_id]

        def get_connected_ids(
            connecting_point,
            current_ft_id,
            search_radius
        ):
            '''
            Searches for connected features at the connecting point, except for the current feature; also returns the search area
            :param QgsGeometry (Point) connecting_point
            :param int current_ft_id
            :param QgsRectangle search_area
            '''
            if search_radius != 0:
                search_area = connecting_point.buffer(search_radius, 10).boundingBox()
            else:
                search_area = connecting_point.boundingBox()
            inters_list = sp_index.intersects(search_area)
            if current_ft_id in inters_list:  # remove self
                inters_list.remove(current_ft_id)
            return inters_list, search_area

        def prepare_visit(
            next_ft_id,
            downstream_id,
            search_area,       
            flip_list,
            finished_segm,
            finished_ids
        ):
            '''
            prepares the required data for the next line segment or a segment which will be stored in the to do list
            :param int next_ft_id
            :param int downstream_id
            :param QgsRectangle search_area
            :param list flip_list
            :param dict finished_segm
            :param list finished_ids
            :return list (next_data, next_connecting_point)
            '''
            next_ft = dissolve_layer.getFeature(next_ft_id)
            next_data = get_features_data(next_ft)
            finished_segm[next_data[2]] = [
                        str(next_data[-1]),
                        downstream_id,
                        str(next_data[-1])
                    ]
            finished_ids.append(next_data[2])
            if next_data[0].intersects(search_area):
                next_connecting_point = next_data[1]
                flip_list.append(next_ft_id)
            else:
                next_connecting_point = next_data[0]
            return [next_data, next_connecting_point]

        '''data of first segment'''
        finished_ids = []  # list to recognise already visited features
        to_do_list = []  # empty list for tributaries to visit later
        current_data = get_features_data(closest_section)  # first_vertex, last_vertex, feature_id, (feature_name)
        out_marker = "Out"  # mark segment as outlet
        start_f_id = current_data[2]
        finished_segm[current_data[2]] = [
                    str(current_data[-1]),
                    out_marker,
                    str(current_data[-1])
                ]
        finished_ids.append(current_data[2])
        
        '''find connecting vertex of (first) current_data, add to flip_list if conn_vert is not vert1'''
        conn_ids_0, search_area_0 = get_connected_ids(current_data[0], current_data[2], search_radius)
        conn_ids_1, search_area_1 = get_connected_ids(current_data[1], current_data[2], search_radius)
        
        if len(conn_ids_1) > 0:  # last vertex connecting
            if len(conn_ids_0) > 0:  # both vertices connecting
                feedback.reportError(
                    self.tr(
                        'The selected segment with id == {0} is connecting two segments.'
                        +' Please chose another segment in layer "{1}" or add a segment as a single outlet' # this part needs to be changed. If I select the mouth but there are other river section downstream, it raises this error.
                    ).format(current_data[2], dissolve_layer))                                              # it needs to be fixed. Change the type of error and ensure that the user click on the mouth of the river.
            else:
                flip_list = [current_data[2]]  # add id to flip list
                conn_ids = conn_ids_1
                search_area = search_area_1

        else:  # first vertex connecting
            flip_list = []
            conn_ids = conn_ids_0  
            search_area = search_area_0
        
        '''loop: while still connected features, add to finished_segm'''
        while True:
            if feedback.isCanceled():
                print('finished so far: '+ str(finished_ids))
                print('current id'+ str(current_data[2]))
                break

            next_data_lists = [
                prepare_visit(
                    next_ft_id,
                    current_data[2],
                    search_area,
                    flip_list,
                    finished_segm,
                    finished_ids
                ) for next_ft_id in conn_ids
            ]

            if len(conn_ids) == 0:
                if len(to_do_list)==0:
                    netw_dict[0] = finished_ids
                    break
                else:
                    current_data, connecting_point = to_do_list[0]
                    to_do_list = to_do_list[1:]
            if len(conn_ids) == 1:
                current_data, connecting_point = next_data_lists[0]
            if len(conn_ids) > 1:
                current_data, connecting_point = next_data_lists[0]
                to_do_list = to_do_list + next_data_lists[1:]

            conn_ids, search_area = get_connected_ids(connecting_point, current_data[2], search_radius)

            '''check for circles'''
            circle_closing_fts = [f_id for f_id in conn_ids if f_id in finished_ids]
            if len(circle_closing_fts) > 0:
                circ_list = circ_list + [[current_data[2], f_id] for f_id in circle_closing_fts]
                conn_ids = [f_id for f_id in conn_ids if not f_id in finished_ids]

        
        '''feedback for circles'''
        if len (circ_list)>0:
            circ_dict = Counter(tuple(sorted(lst)) for lst in circ_list)
            feedback.pushWarning("Warning: Circle closed at NET_ID = ")
            for f_ids, counted in circ_dict.items():
                if counted > 1:
                    feedback.pushWarning(self.tr('{0}, ').format(str(f_ids)))


        '''sink definition'''
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            out_fields,
            dissolve_layer.wkbType(),
            dissolve_layer.sourceCrs())

        '''adjust_flip_list, if option is 2 (against)'''
        if flip_opt == 2:
            all_visited_ids = [f_id for id_list in netw_dict.values() for f_id in id_list]
            flip_list = [f_id for f_id in all_visited_ids if f_id not in flip_list]


        '''add features to sink'''
        features = dissolve_layer.getFeatures()
        for i, feature in enumerate(features):
            if feedback.isCanceled():
                break # Stop the algorithm if cancel button has been clicked
            old_f_id = feature.id()
            outFt = QgsFeature() # Add a feature
            if flip_opt == 0 or flip_opt == 2:
                if str(i) in flip_list:
                    flip_geom = feature.geometry()
                    if flip_geom.isMultipart():
                        multi_geom = QgsMultiLineString()
                        for line in flip_geom.asGeometryCollection():
                            multi_geom.addGeometry(line.constGet().reversed())
                        rev_geom = QgsGeometry(multi_geom)
                    else:
                        rev_geom = QgsGeometry(flip_geom.constGet().reversed())
                    outFt.setGeometry(rev_geom)
                else:
                    outFt.setGeometry(feature.geometry())  # not in flip list
            else:
                outFt.setGeometry(feature.geometry())  # no flip option
            if old_f_id in finished_segm.keys():
                outFt.setAttributes(feature.attributes()+finished_segm[old_f_id])
            else:
                ft_data = get_features_data(feature)
                outFt.setAttributes(feature.attributes()+[str(ft_data[-1]), 'unconnected', 'unconnected'])
            sink.addFeature(outFt, QgsFeatureSink.FastInsert)


        return {self.OUTPUT: dest_id}

        # # save the output layer
        # (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context,
        # dissolve_layer.fields(), dissolve_layer.wkbType(), dissolve_layer.sourceCrs())

        # if dissolve_layer is None:
        #     raise QgsProcessingException(self.tr("Failed to create river layer"))

        # # write features from dissolve_layer to the sink
        # for feature in dissolve_layer.getFeatures():  # name to change
        #     success = sink.addFeature(feature)
        #     if not success:
        #         feedback.pushInfo(f"Failed to add feature: {feature.id()}")

        # return {self.OUTPUT: dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '1 - Fix river network'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return FixRiverNetwork()