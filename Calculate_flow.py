# -*- coding: utf-8 -*-

"""
/***************************************************************************
 APRIORA
                                 A QGIS plugin
 Collection of APRIORA Plugins
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-06-13
        copyright            : (C) 2024 by Universität Rostock
        email                : cristiano.guidi2@uni-rostock.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Universität Rostock'
__date__ = '2024-06-13'
__copyright__ = '(C) 2024 by Universität Rostock'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import processing
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
from PyQt5.QtCore import QVariant
from qgis.PyQt.QtCore import QCoreApplication, Qt, QDir, QVariant
from qgis.core import (QgsProcessingAlgorithm,
                       QgsProcessing,
                       QgsProcessingException,
                       QgsFeature,
                       QgsField,
                       QgsFields,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterField,
                       QgsField,
                       QgsVectorLayer)

class CalculateFlow(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_catch = 'OUTPUT_catch'
    OUTPUT_river = "OUTPUT_river"
    gaugedSubcatchments = 'GaugedSubcatchments'
    ungaugedSubcatchments = 'UngaugedSubcatchments'
    riverNetwork = "RiverNetwork"
    # INPUT_FIELD_ID = 'INPUT_FIELD_ID'
    # INPUT_FIELD_NEXT = 'INPUT_FIELD_NEXT'
    # INPUT_FIELD_PREV = 'INPUT_FIELD_PREV'

    def shortHelpString(self):
        return self.tr(""" This tool estimates the flow for each subcatchment (Subcatchment level) or for each river section (River level).
        Workflow:
        1. Insert the gauged and ungauged subcatchments with geofactors calculated in 3-
        2. Insert the river network calculated in 1-
        3 Click on "Run"
        """)

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.gaugedSubcatchments,
                self.tr('Gauged subcatchments'),
                [QgsProcessing.TypeVectorPolygon]
            )
        )
        
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.ungaugedSubcatchments,
                self.tr('Ungauged subcatchments'),
                [QgsProcessing.TypeVectorPolygon]
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.riverNetwork,
                self.tr('River network'),
                [QgsProcessing.TypeVectorLine]
            )
        )
        
        # self.addParameter(
        #     QgsProcessingParameterField(
        #         self.INPUT_FIELD_ID,
        #         self.tr("ID Field/NET_ID"),
        #         parentLayerParameterName = self.riverNetwork,
        #         type = QgsProcessingParameterField.Any,
        #         defaultValue = 'NET_ID'
        #     )
        # )
        
        # self.addParameter(
        #     QgsProcessingParameterField(
        #         self.INPUT_FIELD_PREV,
        #         self.tr("Prev Node Field/NET_FROM"),
        #         parentLayerParameterName = self.riverNetwork,
        #         type = QgsProcessingParameterField.Any,
        #         defaultValue = 'NET_FROM'
        #     )
        # )
        
        # self.addParameter(
        #     QgsProcessingParameterField(
        #         self.INPUT_FIELD_NEXT,
        #         self.tr("Next Node Field/NET_TO"),
        #         parentLayerParameterName = self.riverNetwork,
        #         type = QgsProcessingParameterField.Any,
        #         defaultValue = 'NET_TO'
        #     )
        # )
        
        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_catch,
                self.tr('Subcatchment level')
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_river,
                self.tr('River level')
            )
        )

    
    #def subcatchmentFlowEstimation(self, parameters, context, feedback, final_output, warnow_subcatch_gf, outputput_catch_key )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        
         # First input data
        # At first, the model needs to be calibrated and validated so it will import data from the 
        # catchments containing the gauging stations (gauged subcatchments).
        # The file imported is a shapefile containing the geofactors previously calculated for each gauged subcatchment.
        # import data from gauged subcatchments 
        
         # Second input data
        # Another input of the model is the subcatchments where we are interested in estimating "Mean Flow" and 
        # "Mean Low Flow". These subcatchments are called "ungauged subcatchments", because we do not have flow information related to them 
        # This input is a polygon file containing the geofactors calculated for each subcatchment.
        # This input will be used later on, after the process of calibration and validation of the model with the gauged subcatchments.
        
        gaug_stat = self.parameterAsSource(parameters, self.gaugedSubcatchments, context)
        warnow_subcatch_gf = self.parameterAsSource(parameters, self.ungaugedSubcatchments, context)
        river_network = self.parameterAsSource(parameters, self.riverNetwork, context)

        ##### FIRST PART OF THE MODEL
        # Selecting input (predictors) and output
        # In this part of the code, we select the number of predictors that will be used in the model and drop
        # the not necessaries columns. The predictors are the geofactors previously calculated. 
        # We also select the output and like we said before, there are 2 outputs of this model: "Mean Low Flow" and "Mean Flow". 
        # In this part of the code we select "Mean Flow" and in a second part we will estimate "Mean Low Flow". [not in this version of the script]

        # Get the field names
        field_names = [field.name() for field in gaug_stat.fields()]

        # extract attribute data from the layer
        features = gaug_stat.getFeatures()
        data = []

        for feature in features:
            # collect the attribute values for each feature
            data.append([feature[field] for field in field_names])
            
        # create dataframe
        gaug_stat_df = pd.DataFrame(data, columns = field_names)

    
        filterCol = ['H_median', 'H_stdev', 'H_min', 'AREA_SC', 'PERI_SC', 'PERI_SC', 'SHAPE_SC', 'S_median', 'S_stdev', 'RN_sum', 'WA_sum', 'FA_sum', 'SA_sum', 'RND', 'PWA', 'FS', 'SS', 'PreYearly_mean', 'PreAugust_mean']
        # select number of features (predictors) and dependent variable
        x = gaug_stat_df.filter(items=filterCol)
        
        y = gaug_stat_df["Mean Flow"]

        ### Random Forest Regressor
        ##### Split the data for calibration (train) and validation (test)

        # prepare the data: divide into train and test set
        # scale the data
        scaler = StandardScaler()
        x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)
        print(x_train)
        x_train = scaler.fit_transform(x_train) 
        x_test = scaler.transform(x_test)

        # Initialize the model
        # model initialization
        model = RandomForestRegressor()

        # model training
        model.fit(x_train,y_train)

        ##### Calibration
        # Here we work with the train dataset (x_train) to calibrate the model. 
        # After, we print the performance of the model through two metrics like RMSE and R^2.
        # I would like to print the metric of RMSE and Rsquared in the log messages panel of the plugin 
        # in order to give an idea of the performance of the model. [The metric is not part of the output]
        # If it is not possible, the "print" command can be deleted. 

        # performance of the trained model
        y_train_pred = model.predict(x_train)
        #print("Calibration RMSE:", mean_squared_error(y_train, y_train_pred, squared=False))
        #print("Calibration R-squared:", r2_score(y_train, y_train_pred))

        ##### Validation
        # Now, we work with the test dataset (x_test) to validate the model and make estimation on new different data. 
        # Like in the calibration, the performance of the model are evaluated by the metrics RMSE and R^2.

        # prediction and evaluation
        y_pred = model.predict(x_test)
        #print("Validation RMSE:", mean_squared_error(y_test, y_pred, squared=False))
        #print("Validation R-squared:", r2_score(y_test, y_pred))


        ##### SECOND PART OF THE MODEL
        ### Estimate flow in ungauged subcatchments
        # Now it is time to run the model with the ungauged subcatchments and make an estimation of "Mean Flow".
        # First, we select the predictors of the model (geofactors) and we drop all the other 
        # columns that are not necessaries.

        # Get the field names
        field_names = [field.name() for field in warnow_subcatch_gf.fields()]

        # extract attribute data from the layer
        features = warnow_subcatch_gf.getFeatures()
        data = []

        for feature in features:
            # collect the attribute values for each feature
            data.append([feature[field] for field in field_names])
            
        # create dataframe
        warnow_subcatch_gf_df = pd.DataFrame(data, columns = field_names)

        # select number of features (predictors) and dependent variable
        x_catch = warnow_subcatch_gf_df.filter(items=filterCol) #filter geofactors

        # scale the data
        x_catch = scaler.transform(x_catch)

        # Run the model to calculate "Mean Flow"
        # estimation of mean flow
        y_catch = model.predict(x_catch)

        # THIRD PART OF THE MODEL
        # The flow is estimated for each ungauged subcatchment and now it is time to store it in a new shapfile. 
        # The goal of this part of the code is to create a new polygon file with 2 columns(+ geometry): 
        # the gbk_lawa code of the ungauged subcatchment where the flow estimation was made,
        # the flow estimation + the geometry of the ungauged subcatchment.

        # create new dataframe
        output_df = pd.DataFrame({"NET_ID": warnow_subcatch_gf_df["NET_ID"],"Mean Flow": y_catch})

        # create new shapefile     
        crs = warnow_subcatch_gf.sourceCrs()
        final_output = QgsVectorLayer("Polygon?crs={}".format(crs.authid()), "output test", "memory")
        final_output_provider = final_output.dataProvider()

        # start editing
        final_output.startEditing()

        # creation of my fields
        for head in output_df.columns:
            # determine the column data type
            if pd.api.types.is_numeric_dtype(output_df[head]):
                field_type = QVariant.Double
            elif pd.api.types.is_string_dtype(output_df[head]):
                field_type = QVariant.String
            else:
                field_type = QVariant.String # default to string for other types

            myField = QgsField(head, field_type)
            final_output.addAttribute(myField)
            
        # update
        final_output.updateFields()

        # addition of features
        for row in output_df.itertuples():
            f = QgsFeature()
            f.setAttributes([row[1], row[2]])  # why only [1] and [2] and not row[1:]?
            final_output.addFeature(f)
            
        # saving changes
        final_output.commitChanges()


        # create a new layer with Mean Flow and gbk_lawa + geometry from warnow_subcatch        
        (sink_catch, dest_id_catch) = self.parameterAsSink(parameters, self.OUTPUT_catch,
        context, final_output.fields(), warnow_subcatch_gf.wkbType(), warnow_subcatch_gf.sourceCrs())

        if sink_catch is None:
            raise QgsProcessingException(self.tr("Failed to create subcatchment sink"))

        # iterate over each subcatchment
        for feature, subcatch_feature in zip(final_output.getFeatures(), warnow_subcatch_gf.getFeatures()):
        
            # extract geometry from the corresponding subcatchment feature
            subcatch_geom = subcatch_feature.geometry()
            
            # create a new feature with combined attributes and geometry
            new_feature = QgsFeature(final_output.fields())
            new_feature.setGeometry(subcatch_geom)

            # copy attributes from the final output
            new_feature.setAttributes(feature.attributes())
            
            # add the new feature to the contributing layer
            sink_catch.addFeature(new_feature)

        # the output of this code is a polygon file containing the code of every ungauged subcatchment (gbk_lawa or another code),
        # the estimated flow for each ungauged subcatchment (Mean Flow) and the geometry of the relative ungauged subcatchment.
        
        # process to transfer the flow from a subcatchment level to a river level
        output_catch_layer = context.takeResultLayer(dest_id_catch)
        if output_catch_layer is None:
            raise QgsProcessingException(self.tr("Failed to register the subcatchment layer"))

        context.temporaryLayerStore().addMapLayer(output_catch_layer)
        feedback.pushInfo(f"Layer name: {output_catch_layer.name()} registered")
        
        join_result = processing.run("native:joinattributestable", 
        {'INPUT':parameters[self.riverNetwork],
        'FIELD':'NET_ID',
        'INPUT_2':output_catch_layer,
        'FIELD_2':'NET_ID',
        'FIELDS_TO_COPY':['Mean Flow'],
        'METHOD':1,
        'DISCARD_NONMATCHING':False,
        'PREFIX':'',
        'OUTPUT':'TEMPORARY_OUTPUT'},
        context=context, feedback=feedback)

        join_output = join_result["OUTPUT"]

        # check if join output contains features
        if join_output.featureCount() == 0:
            feedback.pushWarning("Join resulted in an empty layer!")
        else:
            feedback.pushInfo("Join completed successfully.")


        '''loading the network'''
        #waternet = self.parameterAsVectorLayer(parameters, self.riverNetwork, context)
        waternet = join_output
        wnet_fields = waternet.fields()

        '''names of fields for id,next segment, previous segment'''
        id_field = "NET_ID"
        next_field = "NET_TO"
        prev_field = "NET_FROM"
        calc_field = "Mean Flow"
        
        '''field index for id,next segment, previous segment'''
        idxId = waternet.fields().indexFromName(id_field) 
        idxPrev = waternet.fields().indexFromName(prev_field)
        idxNext = waternet.fields().indexFromName(next_field)
        idxCalc = waternet.fields().indexFromName(calc_field)

        '''load data from layer "waternet" '''
        feedback.setProgressText(self.tr("Loading network layer\n "))
        Data = [[
            str(f.attribute(idxId)),
            str(f.attribute(idxPrev)),
            str(f.attribute(idxNext)),
            f.attribute(idxCalc),
            f.id()
        ] for f in waternet.getFeatures()]
        DataArr = np.array(Data, dtype='object')
        DataArr[np.where(DataArr[:,3] == None),3]=0
        feedback.setProgressText(self.tr("Data loaded \n Calculating flow paths \n"))

        '''segments with numbers'''
        calc_column = np.copy(DataArr[:,3])  # deep copy of column to do calculations on
        calc_segm = np.where(calc_column > 0)[0].tolist()  # indices!
        calc_segm = [i for i in calc_segm if (DataArr[i,1] != 'unconnected' and DataArr[i,2] != 'unconnected')]
        DataArr[:,3] = 0 # set all to 0

        '''function to find next features in the net'''
        def nextFtsCalc (MARKER2):
            vtx_to = DataArr[np.where(DataArr[:,0] == MARKER2)[0].tolist(),2][0] # "to"-vertex of actual segment
            rows_to = np.where(DataArr[:,1] == vtx_to)[0].tolist() # find rows in DataArr with matching "from"-vertices to vtx_to
            unconnected_errors = [DataArr[x, 4] for x in rows_to if DataArr[x, 2]=='unconnected']  # this can only happen after manual editing
            if len(unconnected_errors) > 0:
                waternet.removeSelection()
                waternet.selectByIds(unconnected_errors, waternet.SelectBehavior(1))
                raise QgsProcessingException(
                    'The selected features in the flow are marked as \'unconnected\' '
                    + '(most likely because of manual editing). Please delete the columns with the network information ('
                    + next_field
                    + ', '
                    + prev_field
                    + ') and run tool 1 \"Water Network Constructor\" again.'
                )
            return(rows_to)

        '''function to find flow path'''
        def FlowPath (Start_Row, fp_amount):
            MARKER=DataArr[Start_Row,0] #set MARKER to ID of the first segment
            Weg = [Start_Row]    
            i=0
            while i!=len(DataArr):
                next_rows = nextFtsCalc(MARKER)
                if len(next_rows) > 1: # deviding flow path
                    calc_column[StartRow] = 0
                    calc_column[next_rows] = calc_column[next_rows]+fp_amount/len(next_rows) # this can be changed to weightet separation later
                    out = [Weg, next_rows]
                    break
                if len(next_rows) == 1: # continuing flow path
                    Weg = Weg + next_rows
                    MARKER=DataArr[next_rows[0],0] # change MARKER to Id of next segment 
                if len(next_rows) == 0: # end point
                    out = [Weg]
                    break
                i=i+1
            return (out)

        total2 = len(calc_segm)
        while len(calc_segm) > 0:
            if feedback.isCanceled():
                break
            StartRow = calc_segm[0]
            amount = calc_column[StartRow] # amount to add to flow path
            calc_column[StartRow] = 0 #"delete" calculated amount from list (set 0)
            Fl_pth = FlowPath(StartRow, amount) # get flow path of StartRow 
            if len(Fl_pth)== 2:
                calc_segm = calc_segm + Fl_pth[1] # if flow path devides add new segments to calc_segm
            DataArr[Fl_pth[0],3] = DataArr[Fl_pth[0],3]+amount # Add the amount to the calculated flow path
            calc_segm = calc_segm[1:] # delete used segment
            calc_segm = list(set(calc_segm)) #delete duplicate values
            feedback.setProgress((1-(len(calc_segm)/total2))*100)

        '''add new field'''
        new_field_name = 'calc_'+calc_field
        #define new fields
        out_fields = QgsFields()
        #append fields
        for field in wnet_fields:
            out_fields.append(QgsField(field.name(), field.type()))
        out_fields.append(QgsField(new_field_name, QVariant.Double))
        
        # save the layer
        (sink_river, dest_id_river) = self.parameterAsSink(parameters, self.OUTPUT_river, context,
                                               out_fields, river_network.wkbType(), river_network.sourceCrs())
        
        if sink_river is None:
            raise QgsProcessingException(self.tr("Failed to create river sink"))
        
        # write features from out_fields to the sink
        features = waternet.getFeatures()
        for (i,feature) in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break
            # Add a feature in the sink
            outFt = QgsFeature()
            outFt.setGeometry(feature.geometry())
            outFt.setAttributes(feature.attributes())
            outFt.setAttributes(feature.attributes()+[DataArr[i,3]])
            sink_river.addFeature(outFt, QgsFeatureSink.FastInsert)
        
        # return the result
        return {
            self.OUTPUT_catch: dest_id_catch,
            self.OUTPUT_river: dest_id_river
            }

        del nextFtsCalc
        del FlowPath
        del DataArr


        return {}


    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '4 - Flow estimation'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CalculateFlow()
    