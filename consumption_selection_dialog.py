# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ConsumptionSelectionDialog
                                 A QGIS plugin
 Select consumption data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Cristiano Guidi
        email                : cristiano.guidi2@uni-rostock.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import pandas as pd

from qgis.core import QgsProject, QgsMapLayer, QgsWkbTypes, QgsMessageLog, Qgis #last two for debugging
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QMessageBox # add all the import here instead of using the previous line
from PyQt5.QtGui import QStandardItemModel, QStandardItem
from PyQt5.QtCore import Qt

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'consumption_selection_dialog_base.ui'))


class ConsumptionSelectionDialog(QtWidgets.QDialog, FORM_CLASS):
    def load_csv_to_table(self, csv_path):
        try:
            df = pd.read_csv(csv_path, sep=",")
            model = QStandardItemModel()
            model.setHorizontalHeaderLabels(df.columns.astype(str).tolist())

            for row in df.itertuples(index=False):
                items = []
                for val in row:
                    item = QStandardItem(str(val))
                    #item.setFlags(item.flags() & ~Qt.ItemIsEditable)
                    items.append(item)
                model.appendRow(items)
            
            self.excelTableView.setModel(model)

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not load CSV data: {e}")

    def load_RR_to_table(self, csv_path):
        try:
            df_RR = pd.read_csv(csv_path, sep=",")
            model = QStandardItemModel()
            model.setHorizontalHeaderLabels(df_RR.columns.astype(str).tolist())

            for row in df_RR.itertuples(index=False):
                items = []
                for val in row:
                    item = QStandardItem(str(val))
                    #item.setFlags(item.flags() & ~Qt.ItemIsEditable)
                    items.append(item)
                model.appendRow(items)
            
            self.RRTableView.setModel(model)

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not load CSV data: {e}")
    
    
    
    def __init__(self, parent=None):
        """Constructor."""
        super(ConsumptionSelectionDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        plugin_dir = os.path.dirname(__file__)
        csv_file = os.path.join(plugin_dir, "consumption_dataset.csv")
        RR_file = os.path.join(plugin_dir, "removal_rates.csv")
        try:
            # consumption data
            self.df = pd.read_csv(csv_file, sep=",")
            self.load_csv_to_table(csv_file)
            # removal rate
            self.df_RR = pd.read_csv(RR_file, sep=",")
            self.load_RR_to_table(RR_file)

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not read Excel file: {e}")
            return {}

        # Connect signals
        # tab 1
        self.apiComboBox.currentTextChanged.connect(self.update_filters)
        self.yearComboBox.currentTextChanged.connect(self.update_filters)
        self.countryComboBox.currentTextChanged.connect(self.update_filters)
        self.regionComboBox.currentTextChanged.connect(self.update_filters)
        self.addSelectionButton.clicked.connect(self.add_selection)
        self.saveSelectionButton.clicked.connect(self.save_selection_to_file)
        self.removeSelectionButton.clicked.connect(self.remove_selected_item)
        self.resetButton.clicked.connect(self.reset_filters)
        self.closeButton.clicked.connect(self.close)
        self.update_filters()
        self.addButton_tab1.clicked.connect(lambda: self.add_row_to_table(self.excelTableView))
        self.removeButton_tab1.clicked.connect(lambda: self.remove_selected_row(self.excelTableView))
        self.restoreButton_1.clicked.connect(lambda: self.load_csv_to_table(csv_file))
        # tab 2
        self.addButton_tab2.clicked.connect(lambda: self.add_row_to_table(self.RRTableView))
        self.removeButton_tab2.clicked.connect(lambda: self.remove_selected_row(self.RRTableView))
        self.restoreButton_2.clicked.connect(lambda: self.load_RR_to_table(RR_file))
        # tab 3
        self.WWTPcomboBox.currentIndexChanged.connect(self.update_field_combos)
        self.loadButton.clicked.connect(self.load_wwtp_table)
        self.populate_layer_combo()
        self.restoreButton_3.clicked.connect(self.load_wwtp_table)
        self.saveButton.clicked.connect(self.save_wwtp_table_to_csv)


    def update_filters(self):
        current_api = self.apiComboBox.currentText()
        current_year = self.yearComboBox.currentText()
        current_country = self.countryComboBox.currentText()
        current_region = self.regionComboBox.currentText()

        # df_filtered = self.df.copy()

        # if current_api: df_filtered = df_filtered[df_filtered['API name'] == current_api]
        # if current_year: df_filtered = df_filtered[df_filtered['year'].astype(str) == current_year]
        # if current_country: df_filtered = df_filtered[df_filtered['country'] == current_country]
        # if current_region: df_filtered = df_filtered[df_filtered['region'] == current_region]

        # self.set_combo_items(self.apiComboBox, sorted(df_filtered['API name'].unique()), current_api)
        # self.set_combo_items(self.yearComboBox, sorted(df_filtered['year'].astype(str).unique()), current_year)
        # self.set_combo_items(self.countryComboBox, sorted(df_filtered['country'].unique()), current_country)
        # self.set_combo_items(self.regionComboBox, sorted(df_filtered['region'].unique()), current_region)

        df = self.df

        # create filtered versions of the dataframe for each combo box
        df_api = df.copy()
        if current_year:
            df_api = df_api[df_api['year'].astype(str) == current_year]
        if current_country: 
            df_api = df_api[df_api['country'] == current_country]
        if current_region: 
            df_api = df_api[df_api['region'] == current_region]

        df_year = df.copy()
        if current_api:
            df_year = df_year[df_year['API name'] == current_api]
        if current_country: 
            df_year = df_year[df_year['country'] == current_country]
        if current_region: 
            df_year = df_year[df_year['region'] == current_region]

        df_country = df.copy()
        if current_api:
            df_country = df_country[df_country['API name'] == current_api]
        if current_year:
            df_country = df_country[df_country['year'].astype(str) == current_year]
        if current_region: 
            df_country = df_country[df_country['region'] == current_region]

        df_region = df.copy()
        if current_api:
            df_region = df_region[df_region['API name'] == current_api]
        if current_year:
            df_region = df_region[df_region['year'].astype(str) == current_year]
        if current_country: 
            df_region = df_region[df_region['country'] == current_country]

        self.set_combo_items(self.apiComboBox, sorted(df_api['API name'].unique()), current_api)
        self.set_combo_items(self.yearComboBox, sorted(df_year['year'].astype(str).unique()), current_year)
        self.set_combo_items(self.countryComboBox, sorted(df_country['country'].unique()), current_country)
        self.set_combo_items(self.regionComboBox, sorted(df_region['region'].unique()), current_region)


    """
    Tab 1 - Consumption data
    """
    
    def set_combo_items(self, combo, items, current):
        block = combo.blockSignals(True)
        combo.clear()
        combo.addItem("")
        combo.addItems(items)
        if current in items:
            combo.setCurrentText(current)
        combo.blockSignals(block)

    def add_selection(self):
        filters = self.get_selected_filters()

        # check that all fields are filled
        if not all(filters.values()):
            QMessageBox.warning(self, "Incomplete", "Please select all fields before adding.")
            return

        text = f"{filters['API name']}, {filters['year']}, {filters['country']}, {filters['region']}"

        # avoid duplicates
        for i in range(self.selectionListWidget.count()):
            if self.selectionListWidget.item(i).text() == text:
                QMessageBox.information(self, "Duplicate", "This selection is already added.")
                return

        self.selectionListWidget.addItem(text)

    def remove_selected_item(self):
        selected_items = self.selectionListWidget.selectedItems()
        for item in selected_items:
            row = self.selectionListWidget.row(item)
            self.selectionListWidget.takeItem(row)

    def reset_filters(self):
        self.apiComboBox.setCurrentIndex(0)
        self.yearComboBox.setCurrentIndex(0)
        self.countryComboBox.setCurrentIndex(0)
        self.regionComboBox.setCurrentIndex(0)

    def add_row_to_table(self, table_view):
        model = table_view.model()
        if model:
            cols = model.columnCount()
            new_items = [QStandardItem("") for _ in range(cols)]
            for item in new_items:
                item.setFlags(item.flags() | Qt.ItemIsEditable)
            model.appendRow(new_items)

    def remove_selected_row(self, table_view):
        model = table_view.model()
        selection = table_view.selectionModel().selectedRows()
        for index in sorted(selection, reverse = True):
            model.removeRow(index.row())

    def save_selection_to_file(self):
        # get the plugin's directory path
        plugin_dir = os.path.dirname(__file__)

        # define the file path in the plugin's directory
        file_path = os.path.join(plugin_dir, "user_selection.txt")

        # get the selected items
        selected_items = []
        for index in range(self.selectionListWidget.count()):
            item = self.selectionListWidget.item(index)
            selected_items.append(item.text())

        # check it there are any selections
        if selected_items:
            try:
                # Create the text file and write the selections
                with open(file_path, "w") as file:
                    for selection in selected_items:
                        file.write(f"{selection}\n")

                # show successfull saving
                QMessageBox.information(self, "Success", "Selection saved successfully!")

            except PermissionError:
                QMessageBox.critical(self, "Error", f"Permission denied: could not save the file to:\n{file_path}")

        else:
            QMessageBox.warning(self, "No selections", "There are no selections to save")

    
    def get_selected_filters(self): # not necessary I think
        return {
            "API name": self.apiComboBox.currentText(),
            "year": self.yearComboBox.currentText(),
            "country": self.countryComboBox.currentText(),
            "region": self.regionComboBox.currentText()
        }

    """
    Tab 2 - Removal rate
    """

    
    """
    Tab 3 - Custom table
    """
    
    def populate_layer_combo(self):
        self.WWTPcomboBox.clear()
        layers = [layer for layer in QgsProject.instance().mapLayers().values() if layer.type() == QgsMapLayer.VectorLayer and layer.geometryType() == QgsWkbTypes.PointGeometry]
        self.vector_layers = layers
        for layer in layers:
            self.WWTPcomboBox.addItem(layer.name())

    def update_field_combos(self):
        index = self.WWTPcomboBox.currentIndex()
        if index == -1:
            return

        layer = self.vector_layers[index]
        field_names = [field.name() for field in layer.fields()]

        self.IDcomboBox.clear()
        self.NamecomboBox.clear()
        self.TCcomboBox.clear()
        self.IDcomboBox.addItems(field_names)
        self.NamecomboBox.addItems(field_names)
        self.TCcomboBox.addItems(field_names)

    def load_wwtp_table(self):
        # get the plugin's directory path
        plugin_dir = os.path.dirname(__file__)
        removal_file = os.path.join(plugin_dir, "removal_rates.csv")
        removal_df = pd.read_csv(removal_file)
        QgsMessageLog.logMessage(f"Available columns: {removal_df.columns.tolist()}", level=Qgis.Info)

        try:
            index = self.WWTPcomboBox.currentIndex()
            if index == -1:
                QMessageBox.warning(self, "No Layer selected", "Please select a point shapefile layer.")
                return

            layer = self.vector_layers[index]
            id_field = self.IDcomboBox.currentText()
            name_field = self.NamecomboBox.currentText()
            tc_field = self.TCcomboBox.currentText()
            

            if not id_field or not name_field or not tc_field:
                QMessageBox.warning(self, "Missing Field", "Please select all fields.")
                return

            model = QStandardItemModel()
            
            # get all selected API combinations from the list widget in tab 1
            selections = []
            for i in range(self.selectionListWidget.count()):
                selections.append(self.selectionListWidget.item(i).text().split(", "))

            api_names = [sel[0] for sel in selections]
            removal_names = [f"RR_{api}" for api in api_names]

            model.setHorizontalHeaderLabels(["WWTP ID", "WWTP name", "Technical Class"] + api_names + removal_names)

            for feature in layer.getFeatures():
                api_items = []
                # id and name
                id_val = feature[id_field]
                id_item = QStandardItem(str(id_val))
                api_items.append(id_item)
                name_val = feature[name_field]
                name_item = QStandardItem(str(name_val))
                api_items.append(name_item)

                try:
                    tech_class = int(feature[tc_field])
                except (TypeError, ValueError, KeyError):
                    tech_class = None
                tech_item = QStandardItem(str(tech_class))
                api_items.append(tech_item)
                
                # add each API value based on match
                for api_name, year, country, region in selections:
                    match = self.df[
                        (self.df["API name"] == api_name) &
                        (self.df["year"].astype(str) == year) &
                        (self.df["country"] == country) &
                        (self.df["region"] == region)
                    ]
                    val = match["API input (mg/inh.a)"].values[0] if not match.empty else ""
                    api_item = QStandardItem(str(val))
                    #api_item.setFlags(api_item.flags() & ~Qt.ItemIsEditable)
                    api_items.append(api_item)

                # add removal rates (RR) values
                for api in api_names:
                    # little debugging
                    QgsMessageLog.logMessage(f"Selected API: '{api}'", level=Qgis.Info)
                    QgsMessageLog.logMessage(f"Matching rows: {removal_df[removal_df['API name'].str.strip() == api.strip()]}", level=Qgis.Info)
                    QgsMessageLog.logMessage(f"Tech class: {tech_class}, Column name: TC{tech_class} removal rate", level=Qgis.Info)
                    
                    removal_val = ""
                    removal_row = removal_df[removal_df["API name"] == api]
                    if not removal_row.empty and tech_class:
                        col_name = f"TC{tech_class} removal rate"
                        # little debugging
                        QgsMessageLog.logMessage(f"Raw removal value: {removal_row.iloc[0][col_name]}", level=Qgis.Info)

                        if col_name in removal_row.columns:
                            try:
                                removal_val = float(removal_row.iloc[0][col_name])
                            except Exception:
                                removal_val = ""
                    else:
                        QgsMessageLog.logMessage("No matching row found in removal_df", level=Qgis.Warning)
                    rr_item = QStandardItem(str(removal_val))
                    api_items.append(rr_item)
                
                for item in (id_item, name_item, tech_item):
                    item.setFlags(item.flags() & ~Qt.ItemIsEditable)
                model.appendRow(api_items)


                #model.appendRow([id_item, name_item] + api_items)
            
            self.wwtpTableView.setModel(model)

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not load WWTP data: {e}")

    def save_wwtp_table_to_csv(self):
        model = self.wwtpTableView.model()
        if model is None:
            QMessageBox.warning(self, "No Data", "There is no data to save.")
            return

        plugin_dir = os.path.dirname(__file__)
        save_path = os.path.join(plugin_dir, "wwtp_consumption_table.csv")

        try:
            # extract header
            headers = [model.headerData(col, Qt.Horizontal) for col in range(model.columnCount())]

            # extract rows
            data = []
            for row in range(model.rowCount()):
                row_data = []
                for col in range(model.columnCount()):
                    index = model.index(row, col)
                    row_data.append(index.data())
                data.append(row_data)

            # save using pandas
            df_save = pd.DataFrame(data, columns=headers)
            df_save.to_csv(save_path, index=False)

            QMessageBox.information(self, "Saved", f"Table successfully saved to: \n{save_path}")

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not save file:\n{e}")
