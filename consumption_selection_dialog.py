# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ConsumptionSelectionDialog
                                 A QGIS plugin
 Select consumption data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Cristiano Guidi
        email                : cristiano.guidi2@uni-rostock.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import pandas as pd
import tempfile

from qgis.core import QgsProject, QgsMapLayer, QgsWkbTypes, QgsMessageLog, Qgis #last two for debugging
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QMessageBox, QStyle # add all the import here instead of using the previous line
from PyQt5.QtGui import QStandardItemModel, QStandardItem
from PyQt5.QtCore import Qt

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'consumption_selection_dialog_base.ui'))


class ConsumptionSelectionDialog(QtWidgets.QDialog, FORM_CLASS):
    # def load_csv_to_table(self, csv_path):
    #     try:
    #         df = pd.read_csv(csv_path, sep=",")
    #         self.df = df
    #         model = QStandardItemModel()
    #         model.setHorizontalHeaderLabels(df.columns.astype(str).tolist())

    #         for row in df.itertuples(index=False):
    #             items = []
    #             for val in row:
    #                 item = QStandardItem(str(val))
    #                 #item.setFlags(item.flags() & ~Qt.ItemIsEditable)
    #                 items.append(item)
    #             model.appendRow(items)
            
    #         self.excelTableView.setModel(model)

    #         # remove temporary file if there are
    #         # if self.temp_cons == True:
    #         #     # os.remove(self.temp_consumption_path)
    #         #     # set a flag
    #         #     self.temp_cons = False
    #         self.update_filters()

    #     except Exception as e:
    #         QMessageBox.critical(self, "Error", f"Could not load CSV data: {e}")

    # def load_RR_to_table(self, csv_path):
    #     try:
    #         df_RR = pd.read_csv(csv_path, sep=",")
    #         model = QStandardItemModel()
    #         model.setHorizontalHeaderLabels(df_RR.columns.astype(str).tolist())

    #         for row in df_RR.itertuples(index=False):
    #             items = []
    #             for val in row:
    #                 item = QStandardItem(str(val))
    #                 #item.setFlags(item.flags() & ~Qt.ItemIsEditable)
    #                 items.append(item)
    #             model.appendRow(items)
            
    #         self.RRTableView.setModel(model)

    #         # remove temporary file if there are
    #         # if self.temp_rr == True:
    #         #     # os.remove(self.temp_rr_path)
    #         #     # set a flag
    #         #     self.temp_rr = False

    #     except Exception as e:
    #         QMessageBox.critical(self, "Error", f"Could not load CSV data: {e}")
    
    # def load_PNEC_to_table(self, csv_path):
    #     try:
    #         df_PNEC = pd.read_csv(csv_path, sep=",")
    #         model = QStandardItemModel()
    #         model.setHorizontalHeaderLabels(df_PNEC.columns.astype(str).tolist())

    #         for row in df_PNEC.itertuples(index=False):
    #             items = []
    #             for val in row:
    #                 item = QStandardItem(str(val))
    #                 #item.setFlags(item.flags() & ~Qt.ItemIsEditable)
    #                 items.append(item)
    #             model.appendRow(items)
            
    #         self.PNECTableView.setModel(model)

    #         # remove temporary file if there are
    #         # if self.temp_pnec == True:
    #         #     # os.remove(self.temp_pnec_path)
    #         #     # set a flag
    #         #     self.temp_pnec = False

    #     except Exception as e:
    #         QMessageBox.critical(self, "Error", f"Could not load CSV data: {e}")

    def get_dataset_path(self, original_filename, custom_filename):
        """
        Return the path to the dataset
        If a custom file exists, return that.
        Otherwise return the original file.
        """
        plugin_dir = os.path.dirname(__file__)
        custom_path = os.path.join(plugin_dir, "datasets/custom_dataset", custom_filename)
        original_path = os.path.join(plugin_dir, "datasets/original_dataset", original_filename)

        if os.path.exists(custom_path):
            return custom_path, True    # True = custom file is being used
        else:
            return original_path, False
        
    def load_selection_from_file(self):
        plugin_dir = os.path.dirname(__file__)
        file_path = os.path.join(plugin_dir, "user_selection.txt")

        if os.path.exists(file_path):
            with open(file_path, "r") as file:
                for line in file:
                    line = line.strip()
                    if line:
                        self.selectionListWidget.addItem(line)

    def load_table(self, df, table_view, update_filters):
        """
        Load dataframe to specified table view
        
        csv_path: path to CSV file
        table_view: Target QTableView object
        update_filters: wheter call update_filters after loading
        """
        try:
            model = QStandardItemModel()
            model.setHorizontalHeaderLabels(df.columns.astype(str).tolist())

            for row in df.itertuples(index=False):
                items = []
                for val in row:
                    item = QStandardItem(str(val))
                    items.append(item)
                model.appendRow(items)
            
            # set the table model
            table_view.setModel(model)

            # update filters if needed
            if update_filters:
                self.update_filters()

        except Exception as e:
            #QMessageBox.critical(self, "Error", f"Could not load {csv_path} CSV data: {e}")
            QMessageBox.critical(self, "Error", f"Could not load CSV data: {e}")
    
    
    def __init__(self, parent=None):
        """Constructor."""
        super(ConsumptionSelectionDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        # set a save icon
        self.saveButton_1.setIcon(self.style().standardIcon(QStyle.SP_DialogSaveButton))
        self.saveButton_2.setIcon(self.style().standardIcon(QStyle.SP_DialogSaveButton))
        self.saveButton_tab4.setIcon(self.style().standardIcon(QStyle.SP_DialogSaveButton))
        # set a reload icon
        self.reloadButton_3.setIcon(self.style().standardIcon(QStyle.SP_BrowserReload))
        # self.temp_cons = False
        # self.temp_rr = False
        # self.temp_pnec = False
        # set a flag for save pop-up
        self.flag = False   # check the utility of this flag
        # directory of the databases
        csv_file, self.temp_cons = self.get_dataset_path("consumption_dataset.csv", "consumption_.csv")
        RR_file, self.temp_rr = self.get_dataset_path("removal_rates.csv", "removal_.csv")
        PNEC_file, self.temp_pnec = self.get_dataset_path("PNEC ERA.csv", "PNEC_.csv")
        # try:
        #     # consumption data
        #     self.df = pd.read_csv(csv_file, sep=",")
        #     self.load_csv_to_table(csv_file)
        #     # removal rate
        #     self.df_RR = pd.read_csv(RR_file, sep=",")
        #     self.load_RR_to_table(RR_file)
        #     # PNEC values
        #     self.df_PNEC = pd.read_csv(PNEC_file, sep=",")
        #     self.load_PNEC_to_table(PNEC_file)

        try:
            # consumption data
            self.df = pd.read_csv(csv_file, sep=",")
            self.load_table(self.df, self.excelTableView, True)
            # removal rate
            self.df_RR = pd.read_csv(RR_file, sep=",")
            self.load_table(self.df_RR, self.RRTableView, False)
            # PNEC values
            self.df_PNEC = pd.read_csv(PNEC_file, sep=",")
            self.load_table(self.df_PNEC, self.PNECTableView, False)


        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not read Excel file: {e}")
            return {}

        # Connect signals
        # tab 1
        self.apiComboBox.currentTextChanged.connect(self.update_filters)
        self.yearComboBox.currentTextChanged.connect(self.update_filters)
        self.countryComboBox.currentTextChanged.connect(self.update_filters)
        self.regionComboBox.currentTextChanged.connect(self.update_filters)
        self.load_selection_from_file()
        self.addSelectionButton.clicked.connect(self.add_selection)
        self.saveSelectionButton.clicked.connect(self.save_selection_to_file)
        self.removeSelectionButton.clicked.connect(self.remove_selected_item)
        self.resetButton.clicked.connect(self.reset_filters)
        self.closeButton.clicked.connect(self.close)
        self.update_filters()
        self.addButton_tab1.clicked.connect(lambda: self.add_row_to_table(self.excelTableView))
        self.removeButton_tab1.clicked.connect(lambda: self.remove_selected_row(self.excelTableView))
        self.restoreButton_1.clicked.connect(
            lambda: self.restore_original(
                "consumption_dataset.csv", "consumption_.csv", self.load_table, self.excelTableView, True
            )
        )
        self.saveButton_1.clicked.connect(self.handle_save_consumption)
        
        # tab 2
        self.addButton_tab2.clicked.connect(lambda: self.add_row_to_table(self.RRTableView))
        self.removeButton_tab2.clicked.connect(lambda: self.remove_selected_row(self.RRTableView))
        self.restoreButton_2.clicked.connect(
            lambda: self.restore_original(
                "removal_rates.csv", "removal_.csv", self.load_table, self.RRTableView, False
            )
        )
        self.saveButton_2.clicked.connect(self.handle_save_rr)

        # tab 3
        self.WWTPcomboBox.currentIndexChanged.connect(self.update_field_combos)
        self.loadButton.clicked.connect(self.load_wwtp_table)
        self.populate_layer_combo()
        self.reloadButton_3.clicked.connect(self.populate_layer_combo)
        self.restoreButton_3.clicked.connect(self.load_wwtp_table)
        self.saveButton.clicked.connect(self.save_wwtp_table_to_csv)

        # tab 4
        self.addButton_tab4.clicked.connect(lambda: self.add_row_to_table(self.PNECTableView))
        self.removeButton_tab4.clicked.connect(lambda: self.remove_selected_row(self.PNECTableView))
        self.restoreButton_tab4.clicked.connect(
            lambda: self.restore_original(
                "PNEC ERA.csv", "PNEC_.csv", self.load_table, self.PNECTableView, False
            )
        )
        self.saveButton_tab4.clicked.connect(self.handle_save_pnec)


    def update_filters(self):
        current_api = self.apiComboBox.currentText()
        current_year = self.yearComboBox.currentText()
        current_country = self.countryComboBox.currentText()
        current_region = self.regionComboBox.currentText()

        # # load the original file or the custom one
        # if self.temp_cons:
        #     df = pd.read_csv(self.temp_consumption_path)
        # else:
        #     df = self.df

        # create filtered versions of the dataframe for each combo box
        df = self.df
        df_api = df.copy()
        if current_year:
            df_api = df_api[df_api['year'].astype(str) == current_year]
        if current_country: 
            df_api = df_api[df_api['country'] == current_country]
        if current_region: 
            df_api = df_api[df_api['region'] == current_region]

        df_year = df.copy()
        if current_api:
            df_year = df_year[df_year['API name'] == current_api]
        if current_country: 
            df_year = df_year[df_year['country'] == current_country]
        if current_region: 
            df_year = df_year[df_year['region'] == current_region]

        df_country = df.copy()
        if current_api:
            df_country = df_country[df_country['API name'] == current_api]
        if current_year:
            df_country = df_country[df_country['year'].astype(str) == current_year]
        if current_region: 
            df_country = df_country[df_country['region'] == current_region]

        df_region = df.copy()
        if current_api:
            df_region = df_region[df_region['API name'] == current_api]
        if current_year:
            df_region = df_region[df_region['year'].astype(str) == current_year]
        if current_country: 
            df_region = df_region[df_region['country'] == current_country]

        self.set_combo_items(self.apiComboBox, sorted(df_api['API name'].unique()), current_api)
        self.set_combo_items(self.yearComboBox, sorted(df_year['year'].astype(str).unique()), current_year)
        self.set_combo_items(self.countryComboBox, sorted(df_country['country'].unique()), current_country)
        self.set_combo_items(self.regionComboBox, sorted(df_region['region'].unique()), current_region)


    """
    Tab 1 - Consumption data
    """
    
    def set_combo_items(self, combo, items, current):
        block = combo.blockSignals(True)
        combo.clear()
        combo.addItem("")
        combo.addItems(items)
        if current in items:
            combo.setCurrentText(current)
        combo.blockSignals(block)

    def add_selection(self):
        self.flag = True
        filters = self.get_selected_filters()

        # check that all fields are filled
        if not all(filters.values()):
            QMessageBox.warning(self, "Incomplete", "Please select all fields before adding.")
            return

        text = f"{filters['API name']}, {filters['year']}, {filters['country']}, {filters['region']}"

        # avoid duplicates
        for i in range(self.selectionListWidget.count()):
            if self.selectionListWidget.item(i).text() == text:
                QMessageBox.information(self, "Duplicate", "This selection is already added.")
                return

        self.selectionListWidget.addItem(text)
        self.save_selection_to_file()

    def remove_selected_item(self):
        self.flag = True
        selected_items = self.selectionListWidget.selectedItems()
        for item in selected_items:
            row = self.selectionListWidget.row(item)
            self.selectionListWidget.takeItem(row)
        self.save_selection_to_file()

    def reset_filters(self):
        self.apiComboBox.setCurrentIndex(0)
        self.yearComboBox.setCurrentIndex(0)
        self.countryComboBox.setCurrentIndex(0)
        self.regionComboBox.setCurrentIndex(0)

    def add_row_to_table(self, table_view):
        model = table_view.model()
        if model:
            cols = model.columnCount()
            new_items = [QStandardItem("") for _ in range(cols)]
            for item in new_items:
                item.setFlags(item.flags() | Qt.ItemIsEditable)
            model.appendRow(new_items)

    def remove_selected_row(self, table_view):
        model = table_view.model()
        selection = table_view.selectionModel().selectedRows()
        for index in sorted(selection, reverse = True):
            model.removeRow(index.row())

    def save_temp_table(self, table_view, name):
        model = table_view.model()
        if model is None:
            return None

        headers = [model.headerData(col, Qt.Horizontal) for col in range(model.columnCount())]
        data = []
        for row in range(model.rowCount()):
            row_data = [model.index(row, col).data() for col in range(model.columnCount())]
            data.append(row_data)

        df = pd.DataFrame(data, columns = headers)

        # create a temp file and store path
        plugin_dir = os.path.dirname(__file__)
        custom_dir = os.path.join(plugin_dir, "datasets/custom_dataset")
        os.makedirs(custom_dir, exist_ok=True)
        
        temp_file = os.path.join(custom_dir, f"{name}.csv")
        df.to_csv(temp_file, index=False)
        return temp_file

    def handle_save_consumption(self):
        self.temp_consumption_path = self.save_temp_table(self.excelTableView, "consumption_")
        self.df = pd.read_csv(self.temp_consumption_path, sep=",")
        # self.temp_cons = True
        self.update_filters()
        QMessageBox.information(self, "Success", "Consumption table saved.")


    def restore_original(self, original_filename, custom_filename, loader_func, table_view, update_filters):
        """
        Delete custom dataset (if it exists) and reload the original.
        """
        # consider replacing this part with another function that you already defined before "get_path"
        plugin_dir = os.path.dirname(__file__)
        custom_path = os.path.join(plugin_dir, "datasets/custom_dataset", custom_filename)
        original_path = os.path.join(plugin_dir, "datasets/original_dataset", original_filename)

        # delete custom file if it exists
        if os.path.exists(custom_path):
            os.remove(custom_path)

        # read dataframe
        temp_df = pd.read_csv(original_path, sep=",")

        # update the instance variable
        if "consumption" in original_filename.lower():
            self.df = temp_df
        elif "removal" in original_filename.lower():
            self.df_RR = temp_df
        elif "pnec" in original_filename.lower():
            self.df_PNEC = temp_df

        # reload original
        loader_func(temp_df, table_view, update_filters)

        QMessageBox.information(self, "Success", "Table restored to its original values.")


    
    def save_selection_to_file(self):
        # get the plugin's directory path
        plugin_dir = os.path.dirname(__file__)

        # define the file path in the plugin's directory
        file_path = os.path.join(plugin_dir, "user_selection.txt")

        # get the selected items
        selected_items = []
        for index in range(self.selectionListWidget.count()):
            item = self.selectionListWidget.item(index)
            selected_items.append(item.text())

        # Create the text file and write the selections
        with open(file_path, "w") as file:
            for selection in selected_items:
                file.write(f"{selection}\n")

        if not self.flag:
            QMessageBox.information(self, "Success", "Selection saved successfully!")

        else:
            self.flag = False


    def get_selected_filters(self):
        return {
            "API name": self.apiComboBox.currentText(),
            "year": self.yearComboBox.currentText(),
            "country": self.countryComboBox.currentText(),
            "region": self.regionComboBox.currentText()
        }

    """
    Tab 2 - Removal rate
    """
    def handle_save_rr(self):
        self.temp_rr_path = self.save_temp_table(self.RRTableView, "removal_")
        self.df_RR = pd.read_csv(self.temp_rr_path, sep=",")
        #self.temp_rr = True
        QMessageBox.information(self, "Success", "Removal rate table saved.")

    
    """
    Tab 3 - Custom table
    """
    
    def populate_layer_combo(self):
        self.WWTPcomboBox.clear()
        layers = [layer for layer in QgsProject.instance().mapLayers().values() if layer.type() == QgsMapLayer.VectorLayer and layer.geometryType() == QgsWkbTypes.PointGeometry]
        self.vector_layers = layers
        for layer in layers:
            self.WWTPcomboBox.addItem(layer.name())

    def update_field_combos(self):
        index = self.WWTPcomboBox.currentIndex()
        if index == -1:
            return

        layer = self.vector_layers[index]
        field_names = [field.name() for field in layer.fields()]

        self.IDcomboBox.clear()
        self.NamecomboBox.clear()
        self.TCcomboBox.clear()
        self.IDcomboBox.addItems(field_names)
        self.NamecomboBox.addItems(field_names)
        self.TCcomboBox.addItems(field_names)

    def load_wwtp_table(self):
        # # get the plugin's directory path
        # plugin_dir = os.path.dirname(__file__)
        
        # if self.temp_rr == True:
        #     removal_df = pd.read_csv(self.temp_rr_path)
        # else:
        #     removal_file = os.path.join(plugin_dir, "datasets/original_dataset/removal_rates.csv")
        #     removal_df = pd.read_csv(removal_file)
        #     #QgsMessageLog.logMessage(f"Available columns: {removal_df.columns.tolist()}", level=Qgis.Info)

        removal_df = self.df_RR

        try:
            index = self.WWTPcomboBox.currentIndex()
            if index == -1:
                QMessageBox.warning(self, "No Layer selected", "Please select a point shapefile layer.")
                return

            layer = self.vector_layers[index]
            id_field = self.IDcomboBox.currentText()
            name_field = self.NamecomboBox.currentText()
            tc_field = self.TCcomboBox.currentText()
            

            if not id_field or not name_field or not tc_field:
                QMessageBox.warning(self, "Missing Field", "Please select all fields.")
                return

            model = QStandardItemModel()
            
            # get all selected API combinations from the list widget in tab 1
            selections = []
            for i in range(self.selectionListWidget.count()):
                selections.append(self.selectionListWidget.item(i).text().split(", "))

            api_names = [sel[0] for sel in selections]
            removal_names = [f"RR_{api}" for api in api_names]

            model.setHorizontalHeaderLabels(["WWTP ID", "WWTP name", "Technical Class"] + api_names + removal_names)

            for feature in layer.getFeatures():
                api_items = []
                # id and name
                id_val = feature[id_field]
                id_item = QStandardItem(str(id_val))
                api_items.append(id_item)
                name_val = feature[name_field]
                name_item = QStandardItem(str(name_val))
                api_items.append(name_item)

                try:
                    tech_class = int(feature[tc_field])
                except (TypeError, ValueError, KeyError):
                    tech_class = None
                tech_item = QStandardItem(str(tech_class))
                api_items.append(tech_item)
                
                # add each API value based on match
                #QgsMessageLog.logMessage(f"Flag is {self.temp_cons}")
                for api_name, year, country, region in selections:
                    # df = pd.read_csv(self.temp_consumption_path) if self.temp_cons else self.df     #change the names, confusion can be made
                    df = self.df
                    match = df[
                        (df["API name"] == api_name) &
                        (df["year"].astype(str) == year) &
                        (df["country"] == country) &
                        (df["region"] == region)
                    ]

                    #QgsMessageLog.logMessage(f"Matching rows for {api_name}, {year}, {country}, {region}:\n{match}", level=Qgis.Info)

                    val = match["API input (mg/inh./a)"].values[0] if not match.empty else ""
                    api_item = QStandardItem(str(val))
                    #api_item.setFlags(api_item.flags() & ~Qt.ItemIsEditable)
                    api_items.append(api_item)

                # add removal rates (RR) values
                for api in api_names:
                    # little debugging
                    #QgsMessageLog.logMessage(f"Selected API: '{api}'", level=Qgis.Info)
                    #QgsMessageLog.logMessage(f"Matching rows: {removal_df[removal_df['API name'].str.strip() == api.strip()]}", level=Qgis.Info)
                    #QgsMessageLog.logMessage(f"Tech class: {tech_class}, Column name: TC{tech_class} removal rate", level=Qgis.Info)
                    
                    removal_val = ""
                    removal_row = removal_df[removal_df["API name"] == api]
                    if not removal_row.empty and tech_class:
                        col_name = f"TC{tech_class} removal rate"
                        # little debugging
                        #QgsMessageLog.logMessage(f"Raw removal value: {removal_row.iloc[0][col_name]}", level=Qgis.Info)

                        if col_name in removal_row.columns:
                            try:
                                removal_val = float(removal_row.iloc[0][col_name])
                            except Exception:
                                removal_val = ""
                    else:
                        pass
                        #QgsMessageLog.logMessage("No matching row found in removal_df", level=Qgis.Warning)
                    rr_item = QStandardItem(str(removal_val))
                    api_items.append(rr_item)
                
                for item in (id_item, name_item, tech_item):
                    item.setFlags(item.flags() & ~Qt.ItemIsEditable)
                model.appendRow(api_items)


                #model.appendRow([id_item, name_item] + api_items)
            
            self.wwtpTableView.setModel(model)

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not load WWTP data: {e}")

    def save_wwtp_table_to_csv(self):
        model = self.wwtpTableView.model()
        if model is None:
            QMessageBox.warning(self, "No Data", "There is no data to save.")
            return

        plugin_dir = os.path.dirname(__file__)
        save_path = os.path.join(plugin_dir, "datasets/custom_dataset/wwtp_consumption_table.csv")

        try:
            # extract header
            headers = [model.headerData(col, Qt.Horizontal) for col in range(model.columnCount())]

            # extract rows
            data = []
            for row in range(model.rowCount()):
                row_data = []
                for col in range(model.columnCount()):
                    index = model.index(row, col)
                    row_data.append(index.data())
                data.append(row_data)

            # save using pandas
            df_save = pd.DataFrame(data, columns=headers)
            df_save.to_csv(save_path, index=False)

            QMessageBox.information(self, "Saved", f"Table successfully saved to: \n{save_path}")

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not save file:\n{e}")


    """
    Tab 4 - Removal rate
    """
    def handle_save_pnec(self):
        self.temp_pnec_path = self.save_temp_table(self.PNECTableView, "PNEC_")
        # self.temp_pnec = True
        QMessageBox.information(self, "Success", "PNEC table saved.")
