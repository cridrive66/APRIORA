# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ConsumptionSelectionDialog
                                 A QGIS plugin
 Select consumption data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Cristiano Guidi
        email                : cristiano.guidi2@uni-rostock.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import pandas as pd

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QMessageBox # add all the import here instead of using the previous line
from PyQt5.QtGui import QStandardItemModel, QStandardItem
from PyQt5.QtCore import Qt

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'consumption_selection_dialog_base.ui'))


class ConsumptionSelectionDialog(QtWidgets.QDialog, FORM_CLASS):
    def load_excel_to_table(self, excel_path, sheet_name):
        try:
            df = pd.read_excel(excel_path, sheet_name)
            model = QStandardItemModel()
            model.setHorizontalHeaderLabels(df.columns.astype(str).tolist())

            for row in df.itertuples(index=False):
                items = []
                for val in row:
                    item = QStandardItem(str(val))
                    item.setFlags(item.flags() & ~Qt.ItemIsEditable)
                    items.append(item)
                model.appendRow(items)
            
            self.excelTableView.setModel(model)

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not load Excel data: {e}")
    
    
    
    def __init__(self, parent=None):
        """Constructor."""
        super(ConsumptionSelectionDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        plugin_dir = os.path.dirname(__file__)
        excel_file = os.path.join(plugin_dir, "B2_input.xlsx")
        try:
            self.df = pd.read_excel(excel_file, sheet_name="API input")
            self.load_excel_to_table(excel_file, "API input")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not read Excel file: {e}")
            return {}

        # Connect signals
        self.apiComboBox.currentTextChanged.connect(self.update_filters)
        self.yearComboBox.currentTextChanged.connect(self.update_filters)
        self.countryComboBox.currentTextChanged.connect(self.update_filters)
        self.regionComboBox.currentTextChanged.connect(self.update_filters)
        self.addSelectionButton.clicked.connect(self.add_selection)
        self.removeSelectionButton.clicked.connect(self.remove_selected_item)
        self.resetButton.clicked.connect(self.reset_filters)
        self.button_box.accepted.connect(self.save_selection_to_file)

        self.update_filters()

    def update_filters(self):
        current_api = self.apiComboBox.currentText()
        current_year = self.yearComboBox.currentText()
        current_country = self.countryComboBox.currentText()
        current_region = self.regionComboBox.currentText()

        df_filtered = self.df.copy()

        if current_api: df_filtered = df_filtered[df_filtered['API name'] == current_api]
        if current_year: df_filtered = df_filtered[df_filtered['year'].astype(str) == current_year]
        if current_country: df_filtered = df_filtered[df_filtered['country'] == current_country]
        if current_region: df_filtered = df_filtered[df_filtered['region'] == current_region]

        self.set_combo_items(self.apiComboBox, sorted(df_filtered['API name'].unique()), current_api)
        self.set_combo_items(self.yearComboBox, sorted(df_filtered['year'].astype(str).unique()), current_year)
        self.set_combo_items(self.countryComboBox, sorted(df_filtered['country'].unique()), current_country)
        self.set_combo_items(self.regionComboBox, sorted(df_filtered['region'].unique()), current_region)

    def set_combo_items(self, combo, items, current):
        block = combo.blockSignals(True)
        combo.clear()
        combo.addItem("")
        combo.addItems(items)
        if current in items:
            combo.setCurrentText(current)
        combo.blockSignals(block)

    def add_selection(self):
        filters = self.get_selected_filters()

        # check that all fields are filled
        if not all(filters.values()):
            QMessageBox.warning(self, "Incomplete", "Please select all fields before adding.")
            return

        text = f"{filters['API name']}, {filters['year']}, {filters['country']}, {filters['region']}"

        # avoid duplicates
        for i in range(self.selectionListWidget.count()):
            if self.selectionListWidget.item(i).text() == text:
                QMessageBox.information(self, "Duplicate", "This selection is already added.")
                return

        self.selectionListWidget.addItem(text)

    def remove_selected_item(self):
        selected_items = self.selectionListWidget.selectedItems()
        for item in selected_items:
            row = self.selectionListWidget.row(item)
            self.selectionListWidget.takeItem(row)

    def reset_filters(self):
        self.apiComboBox.setCurrentIndex(0)
        self.yearComboBox.setCurrentIndex(0)
        self.countryComboBox.setCurrentIndex(0)
        self.regionComboBox.setCurrentIndex(0)

    def save_selection_to_file(self):
        # get the plugin's directory path
        plugin_dir = os.path.dirname(__file__)

        # define the file path in the plugin's directory
        file_path = os.path.join(plugin_dir, "user_selection.txt")

        # get the selected items
        selected_items = []
        for index in range(self.selectionListWidget.count()):
            item = self.selectionListWidget.item(index)
            selected_items.append(item.text())

        # check it there are any selections
        if selected_items:
            try:
                # Create the text file and write the selections
                with open(file_path, "w") as file:
                    for selection in selected_items:
                        file.write(f"{selection}\n")

                # show successfull saving
                QMessageBox.information(self, "Success", "Selection saved successfully!")

            except PermissionError:
                QMessageBox.critical(self, "Error", f"Permission denied: could not save the file to:\n{file_path}")

        else:
            QMessageBox.warning(self, "No selections", "There are no selections to save")

    
    def get_selected_filters(self): # not necessary I think
        return {
            "API name": self.apiComboBox.currentText(),
            "year": self.yearComboBox.currentText(),
            "country": self.countryComboBox.currentText(),
            "region": self.regionComboBox.currentText()
        }
