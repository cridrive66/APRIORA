# -*- coding: utf-8 -*-

"""
/***************************************************************************
 APRIORA
                                 A QGIS plugin
 Collection of APRIORA Plugins
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-06-13
        copyright            : (C) 2024 by Universität Rostock
        email                : cristiano.guidi2@uni-rostock.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Cristiano Guidi'
__date__ = '2024-06-13'
__copyright__ = '(C) 2024 by Universität Rostock'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import processing
import os
import pandas as pd
import numpy as np
from PyQt5.QtCore import QVariant
from qgis.PyQt.QtCore import QCoreApplication, Qt, QDir, QVariant
from qgis.PyQt.QtGui import QColor
from qgis.core import (NULL,
                       QgsProcessingAlgorithm,
                       QgsProcessing,
                       QgsProcessingContext,
                       QgsProcessingException,
                       QgsFeature,
                       QgsField,
                       QgsFields,
                       QgsFeatureSink,
                       QgsProject,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterField,
                       QgsProcessingParameterFile,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterVectorLayer,
                       QgsProcessingUtils,
                       QgsRuleBasedRenderer,
                       QgsSymbol,
                       QgsVectorLayer,
                       QgsVectorFileWriter,
                       edit)

class RiskAssessment(QgsProcessingAlgorithm):
    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    riverNetwork = 'RiverNetwork'
    selectedAPI = 'selectedAPI'
    custom = "custom"
    k_param = 'kParam'
    x0_param = 'x0Param'
    OUTPUT = 'OUTPUT'
    dest_id = None

    def shortHelpString(self):
        return self.tr(""" This tool performs the risk assessment of different APIs in a river network.
        """)
    
    #Init tool
    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.riverNetwork,
                self.tr('River network'),
                [QgsProcessing.TypeVectorLine],
                defaultValue = QgsProject.instance().mapLayersByName("River accumulation")[0].id() if QgsProject.instance().mapLayersByName("River accumulation") else None
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                self.selectedAPI,
                self.tr('Select APIs for risk assessment'),
                parentLayerParameterName = self.riverNetwork,
                allowMultiple = True,
                type=QgsProcessingParameterField.Any,
                defaultValue=[
                    f.name() for f in QgsProject.instance().mapLayersByName("River accumulation")[0].fields() if f.name().startswith("conc_") or f.name().startswith("conL_")
                ] if QgsProject.instance().mapLayersByName("River accumulation") else []
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.custom,
                self.tr('Use the custom PNEC values from "Consumption Selection" tool'),
                defaultValue=False
            )
        )

        k_option = QgsProcessingParameterNumber(
            self.k_param,
            self.tr("Scale factor k"),
            type = QgsProcessingParameterNumber.Double,
            defaultValue = 10,
            # minValue = 0.0,
            # maxValue = 10.0,
            optional = False
        )
        
        x0_option = QgsProcessingParameterNumber(
            self.x0_param,
            self.tr('Midpoint value x0'),
            type = QgsProcessingParameterNumber.Double,
            defaultValue = 0.5,
            # minValue = 0.0,
            # maxValue = 1.0,
            optional = False
        )

        #set it as advanced parameter
        k_option.setFlags(k_option.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(k_option)
        x0_option.setFlags(x0_option.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(x0_option)

        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Risk assessment'),
                QgsProcessing.TypeVectorLine
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        river_layer_original = self.parameterAsVectorLayer(parameters, self.riverNetwork, context)
        selected_api_fields = self.parameterAsStrings(parameters, self.selectedAPI, context)
        custom_selection = self.parameterAsBoolean(parameters, self.custom, context)
        k = self.parameterAsDouble(parameters, self.k_param, context)
        x0 = self.parameterAsDouble(parameters, self.x0_param, context)

        # load PNEC table
        if custom_selection:
            plugin_dir = os.path.dirname(__file__)
            PNEC_file = os.path.join(plugin_dir, "datasets/custom_dataset/PNEC_.csv")
            try:
                df_PNEC = pd.read_csv(PNEC_file, sep=",")
            except Exception as e:
                feedback.reportError(f"Could not read CSV file: {e}")
                return {}
            
        if not custom_selection:
            plugin_dir = os.path.dirname(__file__)
            PNEC_file = os.path.join(plugin_dir, "datasets/original_dataset/PNEC ERA.csv")
            try:
                df_PNEC = pd.read_csv(PNEC_file, sep=",")
            except Exception as e:
                feedback.reportError(f"Could not read CSV file: {e}")
                return {}
            
        PNEC_dict = dict(zip(df_PNEC['API name'], df_PNEC['PNEC ng/l']))

        # short tag -> full API mapping
        user_selection = os.path.join(plugin_dir, "user_selection.txt")
        API_map = {}

        try:
            with open(user_selection, "r", encoding="utf-8") as f:
                for line in f:
                    parts = line.strip().split(",")
                    if not parts:
                        continue
                    api_full = parts[0].strip()
                    short_tag = api_full[:4]    # take the first 4 letters
                    API_map[short_tag] = api_full
        except Exception as e:
            feedback.reportError(f"Could not read user_selection.txt: {e}")
            return{}

        # create an indipendent copy of the river layer
        crs = river_layer_original.crs().authid()
        river_layer = QgsVectorLayer("LineString?crs={}".format(crs), "river_layer_copy", "memory")
        provider = river_layer.dataProvider()

        # add the selected concentration fields
        for field_name in selected_api_fields:
            orig_field = river_layer_original.fields().field(field_name)
            provider.addAttributes([orig_field])
        river_layer.updateFields()

        # copy selected features
        for feat in river_layer_original.getFeatures():
            new_feat = QgsFeature(river_layer.fields())
            new_feat.setGeometry(feat.geometry())
            for field in selected_api_fields:
                new_feat[field] = feat[field]
            provider.addFeature(new_feat)

        # add new fields for RQ
        era_field_names = []
        for conc_field in selected_api_fields:
            api_suffix = conc_field[-4:] # last 4 letters (e.g., Carb)
            if conc_field.startswith("conc_"):
                era_field = f"era_{api_suffix}"
            elif conc_field.startswith("conL_"):
                era_field = f"eraL_{api_suffix}"
            else:
                continue    # consider change it and add an error
            provider.addAttributes([QgsField(era_field, QVariant.Double)])
            era_field_names.append((conc_field, era_field, api_suffix))
        river_layer.updateFields()


        # calculate RQ = PEC/PNEC
        river_layer.startEditing()      #not sure if it is necessary

        for conc_field, era_field, api_suffix in era_field_names:
            # map short tag to full API name
            full_api_name = API_map.get(api_suffix)
            if full_api_name is None:
                feedback.pushWarning(f"Skipping {api_suffix}: no mapping found in user_selection.txt")
                continue  # skip if no mapping

            # get PNEC value
            pnec = PNEC_dict.get(full_api_name)
            if pnec is None or pnec == 0:
                feedback.pushWarning(f"PNEC is 0 or no PNEC value found for {full_api_name}")
                continue    # avoid division by zero

            # calculate ERA RA for all features in this column
            for feat in river_layer.getFeatures():
                pec = feat[conc_field]
                if pec is None or pec == NULL:
                    continue    # skip if no value
                rq_era = float(pec) / pnec
                feat[era_field] = rq_era
                river_layer.updateFeature(feat)

        # commit changes
        river_layer.commitChanges()

        """
        Logistic function code by Wojtek Artichowicz
        """

        feedback.pushInfo("Starting calculating the logistic function...\n")

        def logistic(x, k, x0, s):
            if x is None:
                x = 0
            return s / (1 + np.exp(-k * (x - x0)))
        
        def cumulative_function(prefix, name):
            # check if we have mean flow or mean low flow fields
            fields = [f.name() for f in river_layer.fields()]
            era_fields = [f for f in fields if f.startswith(prefix)]

            # add new field
            if era_fields and name not in fields:
                provider.addAttributes([QgsField(name, QVariant.Double)])
                river_layer.updateFields()            
            
            # iterate over all features (river sections)
            for feat in river_layer.getFeatures():
                # for mean flow
                if era_fields:
                    era_values = []
                    for era_field in era_fields:
                        rq_era_value = feat[era_field]
                        # skip NULL or missing values
                        if rq_era_value is None or rq_era_value == NULL:
                            continue
                        era_values.append(float(rq_era_value))
                    
                    # feedback.pushInfo(f"{prefix} values for feature {feat.id()}: {era_values}\n")

                    # keep only RQ >= 1 (exceeding PNEC)
                    exceeding_era = [v for v in era_values if v >= 1]

                    # cumulative sum
                    x = sum(exceeding_era)

                    # apply logistic function
                    cumulative_index = logistic(x, k=k, x0=x0, s=1)

                    # feedback.pushInfo(f"Feature ID: {feat.id()}, cumulative index: {cumulative_index}, Type: {type(cumulative_index)}\n")

                    # store it in a new field
                    feat[name] = float(cumulative_index)
                    river_layer.updateFeature(feat)

        # start editing
        river_layer.startEditing()  
        cumulative_function(prefix="era_", name= "cumul_RQ")
        cumulative_function(prefix="eraL_", name="cumul_RQ_L")
        # commit changes
        river_layer.commitChanges()

        '''sink definition'''
        (sink, self.dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            river_layer.fields(),
            river_layer.wkbType(),
            river_layer.sourceCrs()
        )

        # add to the sink
        for feature in river_layer.getFeatures():
            sink.addFeature(feature)

        return {self.OUTPUT: self.dest_id}
    
    def postProcessAlgorithm(self, context, feedback):
        feedback.setProgressText("\nApplying style to the output layer...")
        sink_layer = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)

        # if sink_layer:
        #     # define rules
        #     rules = [
        #         ('"cumul_RQ_L" < 0.3', "Blue (<0.3)", "blue"),
        #         ('"cumul_RQ_L" >= 0.3 AND "cumul_RQ_L" < 0.4', "Green (0.3-0.4)", "green"),
        #         ('"cumul_RQ_L" >= 0.4 AND "cumul_RQ_L" < 0.6', "Yellow (0.4-0.6)", "yellow"),
        #         ('"cumul_RQ_L" >= 0.6 AND "cumul_RQ_L" < 0.75', "Orange (0.6-0.75)", "orange"),
        #         ('"cumul_RQ_L" >= 0.75 AND "cumul_RQ_L" < 0.9', "Red (0.75-0.9)", "red"),
        #         ('"cumul_RQ_L" >= 0.9', "Dark Red (>0.9)", "darkred")
        #     ]
            
        #     # create root renderer
        #     symbol = QgsSymbol.defaultSymbol(sink_layer.geometryType())
        #     renderer = QgsRuleBasedRenderer(symbol)
        #     root_rule = renderer.rootRule()

        #     # add custom rules
        #     for expression, label, color in rules:
        #         rule_symbol = QgsSymbol.defaultSymbol(sink_layer.geometryType())
        #         rule_symbol.setColor(QColor(color))
        #         rule = QgsRuleBasedRenderer.Rule(rule_symbol, filterExp=expression, label=label)
        #         root_rule.appendChild(rule)

        #     # remove default rule and apply
        #     root_rule.removeChild(root_rule.children()[0])

        #     # apply renderer
        #     sink_layer.setRenderer(renderer)
        #     sink_layer.triggerRepaint()

        if sink_layer:
            style_path = os.path.join(os.path.dirname(__file__), 'styles/risk assessment.qml')
            sink_layer.loadNamedStyle(style_path)
            sink_layer.triggerRepaint()

        return {self.OUTPUT: self.dest_id}



    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '7 - Risk Assessment'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'API emission'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return RiskAssessment()