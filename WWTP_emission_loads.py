# -*- coding: utf-8 -*-

"""
/***************************************************************************
 APRIORA
                                 A QGIS plugin
 Collection of APRIORA Plugins
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-06-13
        copyright            : (C) 2024 by Universität Rostock
        email                : cristiano.guidi2@uni-rostock.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Cristiano Guidi'
__date__ = '2024-06-13'
__copyright__ = '(C) 2024 by Universität Rostock'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import pandas as pd
import os
from qgis.PyQt.QtCore import (QCoreApplication, QVariant)
from qgis.core import ( QgsFeature,
                        QgsFeatureSink,
                        QgsFields,
                        QgsField,
                        QgsProcessing,
                        QgsProcessingAlgorithm,
                        QgsProcessingParameterBoolean,
                        QgsProcessingParameterFeatureSource,
                        QgsProcessingParameterFeatureSink,
                        QgsProcessingParameterField,
                        QgsProcessingParameterString,
                        QgsProcessingUtils,
                        QgsVectorLayer,
                        QgsWkbTypes                    
                        )


class EmissionLoads(QgsProcessingAlgorithm):

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    emissionPoints = 'EmissionPoints'
    idWwtp = "id_wwtp"
    nameWwtp = "name_wwtp"
    connInh = "conn_inh"
    techClass = "tech_class"
    custom = "custom"
    OUTPUT = 'OUTPUT'

    def shortHelpString(self):
        return self.tr(""" This tool calculates the emission load of certain APIs (Active Pharmaceutical Ingredients) at the WWTP (WasteWater Treatment Plant) emission points.
        """)

    #Init tool
    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.emissionPoints,
                self.tr('Emission Points of WWTP'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        # id
        self.addParameter(
            QgsProcessingParameterField(
                self.idWwtp,
                description=self.tr('Select ID field'),
                parentLayerParameterName=self.emissionPoints,
                type=QgsProcessingParameterField.Any
            )
        )

        # name
        self.addParameter(
            QgsProcessingParameterField(
                self.nameWwtp,
                description=self.tr('Select Name field'),
                parentLayerParameterName=self.emissionPoints,
                type=QgsProcessingParameterField.Any
            )
        )


        # inhabitants connected
        self.addParameter(
            QgsProcessingParameterField(
                self.connInh,
                description=self.tr('Select Inhabitants Connected field'),
                parentLayerParameterName=self.emissionPoints,
                type=QgsProcessingParameterField.Any
            )
        )

        # technology class
        self.addParameter(
            QgsProcessingParameterField(
                self.techClass,
                description=self.tr('Select Technology Class field'),
                parentLayerParameterName=self.emissionPoints,
                type=QgsProcessingParameterField.Any
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.custom,
                self.tr('Use the custom table from "Consumption Selection" tool'),
                defaultValue=False
            )
        )
        
        
        # show the user's selection
        # Read contents from the .txt file
        plugin_dir = os.path.dirname(__file__)
        file_path = os.path.join(plugin_dir, "user_selection.txt")

        try:
            with open(file_path, "r") as file:
                lines = file.readlines()
                api_names = [line.strip().split(",")[0] for line in lines if line.strip()]
                selection_text = ", ".join(api_names)
        except Exception as e:
            selection_text = f"Could not load selection.txt: {e}"
        
        self.addParameter(
            QgsProcessingParameterString(
                name="USER_SELECTION_INFO",
                description=self.tr("Current API Selection"),
                defaultValue=selection_text.replace(",", ", ").replace("\n", "\n"),
            )
        )

        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Emission Loads'),
                QgsProcessing.TypeVectorPoint
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        # retrieve the selection of the user
        plugin_dir = os.path.dirname(__file__)
        selection_file = os.path.join(plugin_dir, "user_selection.txt")
        #excel_file = os.path.join(plugin_dir, "B2_input.xlsx")
        cons_file = os.path.join(plugin_dir, "datasets/original_dataset/consumption_dataset.csv")
        removal_file = os.path.join(plugin_dir, "datasets/original_dataset/removal_rates.csv")
        custom_table = os.path.join(plugin_dir, "datasets/custom_dataset/wwtp_consumption_table.csv")

        # read and show content
        if os.path.exists(selection_file):
            try:
                with open(selection_file, 'r') as file:
                    lines = [line.strip() for line in file if line.strip()]
                    selection_data = "\n".join(lines)
                    selections = [line.split(",") for line in lines]

                # push to the panel
                feedback.pushInfo("User selection loaded:\n"+selection_data)

            except Exception as e:
                feedback.reportError(f"Error reading user_selection.txt: {e}")
                selection_data = None
        
        else:
            feedback.reportError("user_selection.txt not found")
            selection_data = None

        # get input parameters
        layer = self.parameterAsVectorLayer(parameters, self.emissionPoints, context)
        id_field = self.parameterAsString(parameters, self.idWwtp, context)
        name_field = self.parameterAsString(parameters, self.nameWwtp, context)
        field_inhabitants = self.parameterAsString(parameters, self.connInh, context)
        tech_field = self.parameterAsString(parameters, self.techClass, context)
        custom_selection = self.parameterAsBoolean(parameters, self.custom, context)

        # clone original fields
        fields = QgsFields()
        fields.append(QgsField(id_field, layer.fields().field(id_field).type()))
        fields.append(QgsField(name_field, layer.fields().field(name_field).type()))

        # add one new field per API
        api_columns = []
        for sel in selections:
            api = sel[0].strip()
            short_field_name = f"{api[:4]}[kg/a]"
            field_name = f"{api}"
            api_columns.append((api, field_name))
            fields.append(QgsField(short_field_name, QVariant.Double))

        # prepare output sink
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            fields,
            layer.wkbType(),
            layer.sourceCrs()
        )

        if custom_selection:
            # load custom table
            custom_df = pd.read_csv(custom_table, sep=",")

            # get API columns
            #api_columns = [api for api in api_names if api in custom_df.columns]

            for feature in layer.getFeatures():
                wwtp_id = feature[id_field]
                geom = feature.geometry()
                
                # match row by WWTP ID
                row = custom_df[custom_df["WWTP ID"] == int(wwtp_id)]
                if row.empty:
                    feedback.reportError(f"No match in custom table for WWTP ID {wwtp_id}")
                    continue

                # get inhabitants
                try:
                    inh = float(feature[field_inhabitants])
                except (TypeError, ValueError):
                    feedback.reportError(f"Inhabitants invalid for {wwtp_id}")
                    inh = 0.0

                new_attrs = [
                    feature[id_field],
                    feature[name_field]
                ]

                for api, _ in api_columns:
                    input_val = float(row.iloc[0][api])
                    rr_col = f"RR_{api}"
                    rr = float(row.iloc[0][rr_col]) if rr_col in row else 0.0

                    adjusted_load = input_val * inh * (1 - rr)/1_000_000
                    new_attrs.append(adjusted_load)

                # create and add the new feature
                new_feature = QgsFeature()
                new_feature.setGeometry(geom)
                new_feature.setAttributes(new_attrs)
                sink.addFeature(new_feature, QgsFeatureSink.FastInsert)




        if not custom_selection:
            # retrieve the consumption data and removal rate from our database
            try:
                df = pd.read_csv(cons_file, sep=",")
                removal_df = pd.read_csv(removal_file, sep=",")
            except Exception as e:
                feedback.reportError(f"Could not read CSV file: {e}")
                return {}
            
            # build dictionary with consumption data
            api_consumption_values = {}
            for (api, field_name), sel in zip(api_columns, selections):
                year = sel[1].strip()
                country = sel[2].strip()
                region = sel[3].strip()

                # find matching row in the Excel database
                match = df[
                    (df["API name"].astype(str) == api) &
                    (df["year"].astype(str) == year) &
                    (df["country"].astype(str) == country) &
                    (df["region"].astype(str) == region)
                ]

                if not match.empty:
                    value = match.iloc[0]["API input (mg/inh.a)"]
                    value_float = float(value)
                    api_consumption_values[field_name] = value_float

                else:
                    feedback.reportError(f"No match found for {api}, {year}, {country}, {region}")
                    api_consumption_values[field_name] = 0
            
            # print consumption values
            feedback.pushInfo(f"\nAPI consumption value: {api_consumption_values} in mg/inh/a")


            # iterate over each emission point
            for feature in layer.getFeatures():
                feedback.pushInfo(f"\nAnalyzing WWTP with ID: {feature[id_field]}")
                attrs = feature.attributes()
                geom = feature.geometry()

                # get inhabitants value
                try:
                    inh = float(feature[field_inhabitants])
                    feedback.pushInfo(f"Connected inhabitant: {inh}")
                except(TypeError, ValueError):
                    inh = 0.0
                    feedback.reportError(f"Inhabitants field missing or invalid for feature {feature[id_field]}")

                # get technical class
                try:
                    tech_class = int(feature[tech_field])
                    feedback.pushInfo(f"Tech class: {tech_class}")
                except (TypeError, ValueError):
                    tech_class = None
                    feedback.reportError(f"Tech class missing or invalid feature for {feature[id_field]}")

                # prepare new attributes with additional API columns
                new_attrs = [
                    feature[id_field],
                    feature[name_field]
                ]

                for api_field, consumption_value in api_consumption_values.items():
                    # get the removal rate of each specific API
                    removal_row = removal_df[removal_df["API name"] == api_field]
                    if not removal_row.empty and tech_class and f"TC{tech_class} removal rate" in removal_row.columns:
                        try:
                            removal_rate = float(removal_row.iloc[0][f"TC{tech_class} removal rate"])
                            feedback.pushInfo(f"Removal rate of {api_field}: {removal_rate}\n")
                        except Exception as e:
                            feedback.reportError(f"Could not find removal rate for {api_field}, TC{tech_class}: {e}")
                            removal_rate = 0.0
                    else:
                        removal_rate = 0.0
                        feedback.reportError(f"No removal found rate for {api_field} and TC{tech_class}")
                    
                    # calculate final load
                    load = consumption_value*inh
                    adjusted_load = (load*(1-removal_rate)/1000000)
                    new_attrs.append(adjusted_load)

                # create and add the new feature
                new_feature = QgsFeature()
                new_feature.setGeometry(geom)
                new_feature.setAttributes(new_attrs)
                sink.addFeature(new_feature, QgsFeatureSink.FastInsert)
            

        return {self.OUTPUT: dest_id}

    
    
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '5 - Emission Loads'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'API emission'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return EmissionLoads()