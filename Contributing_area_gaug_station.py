# -*- coding: utf-8 -*-

"""
/***************************************************************************
 APRIORA
                                 A QGIS plugin
 Collection of APRIORA Plugins
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-06-13
        copyright            : (C) 2024 by Universität Rostock
        email                : cristiano.guidi2@uni-rostock.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Universität Rostock'
__date__ = '2024-06-13'
__copyright__ = '(C) 2024 by Universität Rostock'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import * #change
import processing
import numpy as np

class UpstreamDownstream(QgsProcessingAlgorithm):
    riverNetwork = "RiverNetwork"
    catchmentAreas = 'CatchmentAreas'
    gaugingStations = "GaugingStations"
    OUTPUT_OPTION = 'OUTPUT_OPTION'
    OUTPUT = "OUTPUT"
    OUTPUT_coded = "OUTPUT_coded"

    def shortHelpString(self):
        return self.tr(""" This tool calculates the contributing subcatchments of each gauging station. This output can be visualized as a single shapefile by choosing the option "aggregated output" or as a single shapefile for each gauging station with the option "add also contributing subcatchments". 
        The second output "coded subcatchments" overlap with the input catchment file but has a coded system necessary for the next steps of the plugin.
        Workflow:
        1. Choose the catchment file, the output from "1 - Fix river network" as river network and the gauging stations.
        2. Select which kind of output would you like to display.
        3. Click on "Run".

        """)

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.catchmentAreas,
                self.tr('Catchment areas'),
                [QgsProcessing.TypeVectorPolygon]
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.riverNetwork,
                self.tr('River network'),
                [QgsProcessing.TypeVectorLine]
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.gaugingStations,
                self.tr('Gauging stations'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterEnum(
                self.OUTPUT_OPTION,
                self.tr("How do you want to display the gauged subcatchments?"),
                ['aggregated output','add also single gauged subcatchments'],
                defaultValue=[0]
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Gauged subcatchments'),
                QgsProcessing.TypeVectorPolygon
            )
        )
    
        # add a second output that is the subcatchments with the "NET_ID" code
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_coded,
                self.tr('Coded subcatchments'),
                QgsProcessing.TypeVectorPolygon
            )
        )


    def processAlgorithm(self, parameters, context, feedback):
        source = self.parameterAsSource(
            parameters,
            self.catchmentAreas,
            context
        )
        if source is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.catchmentAreas))

        '''output option'''
        out_opt = self.parameterAsInt(parameters, self.OUTPUT_OPTION, context)

        '''loading the subcatchments'''
        feedback.setProgressText(self.tr("Loading subcatchments..\n "))
        subcatch = self.parameterAsVectorLayer(parameters, self.catchmentAreas, context)

        '''loading the network'''
        feedback.setProgressText(self.tr("Loading network..\n "))
        waternet = self.parameterAsVectorLayer(parameters, self.riverNetwork, context)
        waterFt = waternet.getFeatures()

        '''loading the gauging stations'''
        gaug_stat = self.parameterAsVectorLayer(parameters, self.gaugingStations, context)

        '''names of fields for id,next segment, previous segment'''
        id_field = "NET_ID"
        next_field = "NET_FROM"
        prev_field = "NET_TO"
        
        '''field index for id,next segment, previous segment'''
        idxId = waternet.fields().indexFromName(id_field)
        idxPrev = waternet.fields().indexFromName(next_field)
        idxNext = waternet.fields().indexFromName(prev_field)

        if idxId == -1 or idxPrev == -1 or idxNext == -1:
            raise QgsProcessingException("Required fields (NET_ID, NET_FROM, NET_TO) not found in river network.")

    
        # let's join the subcatchment and the river network so we transfer the IDs from the river network
        # to the subcatchments. This is useful for later when we are extracting the subcatchments containing specific IDs
        subcat_layer_with_duplicate = processing.run("native:joinattributesbylocation", {
            'INPUT': subcatch,
            'PREDICATE':[0,1],
            'JOIN': waternet,
            'JOIN_FIELDS':['NET_ID'],   # instead of "NET_ID", consider using "id_apr"
            'METHOD':0,
            'DISCARD_NONMATCHING':True,
            'PREFIX':'',
            'OUTPUT':'TEMPORARY_OUTPUT'})["OUTPUT"]
        feedback.pushInfo(f"\nNumber of features in the subcat_layer_with_duplicate: {subcat_layer_with_duplicate.featureCount()}")
        # QgsProject.instance().addMapLayer(subcat_layer_with_duplicate)

        # delete duplicate geometries
        subcat_layer = processing.run("native:deleteduplicategeometries", {
            'INPUT':subcat_layer_with_duplicate,
            'OUTPUT':'TEMPORARY_OUTPUT'})["OUTPUT"]
        feedback.pushInfo(f"\nNumber of features in the subcat_layer: {subcat_layer.featureCount()}")
        # QgsProject.instance().addMapLayer(subcat_layer)

        # initialize the feature sink for coded subcatchments
        (sink_coded, dest_id_coded) = self.parameterAsSink(
            parameters,
            self.OUTPUT_coded,
            context,
            subcat_layer.fields(),
            subcat_layer.wkbType(),
            subcat_layer.sourceCrs()
        )

        for feature in subcat_layer.getFeatures():
            sink_coded.addFeature(feature)
            

        # we do the same with the gauging stations. So we have the same IDs to identify river network, gauging stations and subcatchments
        gaug_result = processing.run("native:joinattributesbylocation", {
            'INPUT': gaug_stat,
            'PREDICATE':[0],
            'JOIN': subcat_layer,
            'JOIN_FIELDS':['NET_ID'],
            'METHOD':0,
            'DISCARD_NONMATCHING':True,
            'PREFIX':'',
            'OUTPUT':'TEMPORARY_OUTPUT'})
        gaug_id = gaug_result["OUTPUT"]
        gaugFt = gaug_id.getFeatures()

        feedback.pushInfo(f"\nNumber of features in the gaug_id: {gaug_id.featureCount()}")

        ### add another join by attribute where we pass the "Mean Flow" column from the gauging station to the subcatchment
        join_result = processing.run("native:joinattributesbylocation", {
            'INPUT': subcat_layer,
            'PREDICATE':[1],    
            'JOIN': gaug_stat,
            'JOIN_FIELDS':['Mean Flow'],
            'METHOD':0,
            'DISCARD_NONMATCHING':False,
            'PREFIX':'',
            'OUTPUT':'TEMPORARY_OUTPUT'})
        join_layer = join_result["OUTPUT"]

        
        # initialize the feature sink for aggregated output
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            join_layer.fields(),
            join_layer.wkbType(),
            join_layer.sourceCrs()
        )

    
        def nextFtsSel (Sect, MARKER2):
                if Sect == 'U':
                    clm_current = 1
                    clm_search = 2
                if Sect == 'D':
                    clm_current = 2
                    clm_search = 1
                vtx_connect = DataArr[np.where(DataArr[:,0] == MARKER2)[0].tolist(),clm_current][0] # connecting vertex of actual segment
                rows_connect = np.where(DataArr[:,clm_search] == vtx_connect)[0].tolist() # find rows in DataArr with matching vertices to vtx_connect
                unconnected_errors = [DataArr[x, 3] for x in rows_connect if DataArr[x, clm_current]=='unconnected']  # this can only happen after manual editing
                if len(unconnected_errors) > 0:
                    waternet.removeSelection()
                    waternet.selectByIds(unconnected_errors, waternet.SelectBehavior(1))
                    raise QgsProcessingException(
                        'The selected features in the flow are marked as \'unconnected\' '
                        + '(most likely because of manual editing). Please delete the columns with the network information ('
                        + next_field
                        + ', '
                        + prev_field
                        + ') and run tool 1 \"Water Network Constructor\" again.'
                    )
                return(rows_connect)


        def find_closest_river_section(outlet_point, river_network):
            '''
            Finds the closest river section to the gauging station
            '''
            closest_section = None
            min_distance = float("inf")

            # convert the outlet_point to QgsGeometry
            outlet_geometry = QgsGeometry.fromPointXY(outlet_point)

            # iterate through river network sections and find the closest
            for feature in river_network.getFeatures():
                section_geom = feature.geometry()
                distance = section_geom.distance(outlet_geometry)
                feedback.pushInfo(f"\nAnalyzing section [NET_ID]: {feature['NET_ID']} \nDistance to the outlet point: {distance}")

                if distance < min_distance:
                    min_distance = distance
                    closest_section = feature

            if closest_section:
                feedback.pushInfo(f"\nClosest section found: [NET_ID]: {closest_section["NET_ID"]} \n Distance: {min_distance}")
            else:
                feedback.pushInfo("\nNo closest section found.")

            return closest_section


        '''Find upstream network for each gauging station'''
        feedback.setProgressText("Processing gauging stations...")
        
        for station in gaugFt:      # add an error in case gaugFt is empty
            # little debugging
            feedback.pushInfo(f"\nProcessing gauging station ID: {station.id()}")

            outlet_point = station.geometry().asPoint()
            closest_feature = find_closest_river_section(outlet_point, waternet)

            # raise an error in case closest feature is none?

            '''getting the selected segment'''
            startF = closest_feature  # feature to start with
            if not startF:
                feedback.reportError(self.tr('{0}: No river network found close to the gauging station ').format(self.displayName()))
                raise QgsProcessingException()
            else: 
                startId = startF.id()
                if startF.attributes()[idxId] is not None:
                    StartMarker = startF.attributes()[idxId]
                else:
                    feedback.reportError('This segment has an invalid ID (NULL)')
                    raise QgsProcessingException()
                if startF.attributes()[idxNext] == 'unconnected' or startF.attributes()[idxPrev] == 'unconnected':
                    feedback.reportError(self.tr('{0}: Unconnected segment selected.').format(self.displayName()))
                    raise QgsProcessingException()

            '''selection: flow path upstream/downstream
            downstream: 1
            upstream: 0    # in this case, only upstream is interesting
            '''
            Section = 'U'
            Section_long = 'upstream'

            
            '''load data from layer "waternet" '''
            Data = [[str(f.attribute(idxId)),str(f.attribute(idxPrev)),str(f.attribute(idxNext)),f.id()] for f in waternet.getFeatures()]  # 0:id, 1:from, 2:to, 3id
            DataArr = np.array(Data, dtype= 'object') # save Data as numpy array
            feedback.setProgressText(self.tr("Data loaded\n Calculating {0}\n").format(str(Section_long)))
            feedback.setProgress(20)
        
            '''this was planned as an option: should the first selected segment be part of the final selection?
            at the moment it´s permanently part of the final selection'''
            first_in_selection = True
            if first_in_selection==False:
                net_route=list()
            else:
                net_route = [startId]

            '''find flow path upstream or downstream'''
            MARKER=str(StartMarker) # NET_ID of first segment
            safe=["X"] #a list to safe segments when the net separates; "X" indicates an empty list and works as a MARKER for the while loop below
            forks = [] # a list for forks in flow path...because forks are interesting....
            origins = [] # a list for origins/river heads upstream

            i=1
            total = 70 / source.featureCount() if source.featureCount() else 0 # for feedback between 20% and 90%
            while str(MARKER) != 'X':
                if feedback.isCanceled():
                    break
                next_rows = nextFtsSel (Section, MARKER)
                if len (next_rows) > 0: # sometimes segments are saved in net_route...then they are deleted
                    next_rows = [Z for Z in next_rows if DataArr[Z,3] not in net_route]
                    net_route = net_route + DataArr[next_rows, 3].tolist()
                if len(next_rows) > 1:
                    if Section == 'D':
                        forks = forks + [MARKER]
                    MARKER=DataArr[next_rows[0],0]# change MARKER to the NET_ID of one of the next segments
                    safe=safe + DataArr[next_rows[1:],0].tolist()
                if len(next_rows) == 1:
                    MARKER=DataArr[next_rows[0],0]
                if len(next_rows) == 0:
                    if Section == 'U':
                        origins = origins + [MARKER]
                    MARKER = safe[-1] #change MARKER to the last "saved" NET_ID
                    safe=safe[:-1] #delete used NET_ID from "safe"-list
                feedback.setProgress(20+total*i)
                i+=1
            del i

            # little debugging
            feedback.pushInfo(f"\nPrint net_route: {net_route}")

            # convert net_route (feature IDs) to a set for a faster loop
            net_route_set = set(net_route)

            # extract corresponding NET_ID values
            net_id_values = []
            for feature in waternet.getFeatures():
                if feature.id() in net_route_set:
                    net_id_values.append(feature["NET_ID"])

            # little debugging
            feedback.pushInfo(f"Extracted NET_ID values: {net_id_values}")
            
            # construct the expression to filter the subcatchment based on the IDs stored in net_id_values
            net_id_str = ", ".join(map(str, net_id_values)) # convert IDs to a comma-separeted string
            expression = f'"NET_ID" IN ({net_id_str})'

            # extract upstream subcatchments
            upstream_catch_result = processing.run("native:extractbyexpression", {
                'INPUT': join_layer,
                'EXPRESSION': expression,
                'OUTPUT':'TEMPORARY_OUTPUT'})
            upstream_catch = upstream_catch_result["OUTPUT"]

            # # add the extracted layer to the map
            # QgsProject.instance().addMapLayer(upstream_catch)
            # feedback.pushInfo(f"Added extracted subcatchments for station ID: {station.id()} to the map.")

            # dissolve the contributing subcatchments to have only one area
            dissolve_result = processing.run("native:dissolve",{
                'INPUT':upstream_catch,
                'FIELD':[],
                'SEPARATE_DISJOINT':False,
                'OUTPUT':'TEMPORARY_OUTPUT'
                })
            dissolve_layer = dissolve_result["OUTPUT"]

            # I want the output to have the geometry of dissolve_layer and the feature corresponding to the subcatchment with the gauging ID
            net_id_gaug = station["NET_ID"]

            # find the subcatchment with the same NET_ID
            matching_attributes = None
            for feature in join_layer.getFeatures():
                if feature["NET_ID"] == net_id_gaug:
                    matching_attributes = feature.attributes()
                    break

            if not matching_attributes:
                feedback.pushInfo(f"\nWarning: no subcatchment found with NET_ID {net_id_gaug}. Skipping.")
                continue
            
            # store the result in the output
            dissolve_feature = next(dissolve_layer.getFeatures())
            dissolve_geom = dissolve_feature.geometry()

        
            # aggregate output
            # create a new feature with the fields from the join_layer
            new_feature = QgsFeature(join_layer.fields())  # don't know if it is necessary
            new_feature.setGeometry(dissolve_geom)
            # set the attributes from the gauging station
            new_feature.setAttributes(matching_attributes)
            # add the new feature to the sink
            sink.addFeature(new_feature)

            if out_opt == 1:
                # dynamic output
                new_layer = QgsVectorLayer(
                    f"Polygon?crs={gaug_stat.crs().toWkt()}",
                    f"Subcatchment_station_{station["NET_ID"]}",
                    "memory"
                )
                new_layer_data_provider = new_layer.dataProvider()

                # add fields and create new feature
                new_layer_data_provider.addAttributes(join_layer.fields())
                new_layer.updateFields()
                new_feature = QgsFeature(new_layer.fields())
                new_feature.setGeometry(dissolve_geom)
                new_feature.setAttributes(matching_attributes)
                new_layer_data_provider.addFeature(new_feature)
                new_layer.updateExtents()

                # save the layer to a temporary file
                temp_file_path = QgsProcessingUtils.generateTempFilename(f"Subcatchment_station_{station["NET_ID"]}.shp")
                QgsVectorFileWriter.writeAsVectorFormat(
                    new_layer, temp_file_path, "UTF-8", new_layer.crs(), "ESRI Shapefile"
                )

                # register the layer for adding to the map
                context.addLayerToLoadOnCompletion(
                    temp_file_path,
                    QgsProcessingContext.LayerDetails(
                        name = f"Subcatchment_station_{station['NET_ID']}",
                        project = context.project()
                    )
                )


         
        return {
            self.OUTPUT: dest_id,
            self.OUTPUT_coded: dest_id_coded
            }
     


    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '2 - Contributing area of gauging station'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return UpstreamDownstream()




















